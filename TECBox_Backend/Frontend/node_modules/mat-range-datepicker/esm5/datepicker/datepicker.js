import * as tslib_1 from "tslib";
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directionality } from '@angular/cdk/bidi';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE, UP_ARROW } from '@angular/cdk/keycodes';
import { Overlay, OverlayConfig, } from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import { DOCUMENT } from '@angular/common';
import { filter, take } from 'rxjs/operators';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Inject, inject, InjectionToken, Input, NgZone, Optional, Output, ViewChild, ViewContainerRef, ViewEncapsulation, } from '@angular/core';
import { mixinColor } from '@angular/material/core';
import { MatDialog } from '@angular/material/dialog';
import { merge, Subject, Subscription } from 'rxjs';
import { RangeCalendar } from './range-calendar';
import { matDatepickerAnimations } from './datepicker-animations';
import { createMissingDateImplError } from './datepicker-errors';
import { DateAdapter } from '../datetime/date-adapter';
/**
 * Used to generate a unique ID for each datepicker instance.
 */
var /** @type {?} */ datepickerUid = 0;
/**
 * Injection token that determines the scroll handling while the calendar is open.
 */
export var /** @type {?} */ MAT_DATEPICKER_SCROLL_STRATEGY = new InjectionToken('mat-range-datepicker-scroll-strategy', {
    providedIn: 'root',
    factory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY,
});
/**
 * \@docs-private
 * @return {?}
 */
export function MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY() {
    var /** @type {?} */ overlay = inject(Overlay);
    return function () { return overlay.scrollStrategies.reposition(); };
}
/**
 * \@docs-private
 */
var matRangeDatepickerContentBase = /** @class */ (function () {
    /**
     * @param {?} _elementRef
     */
    function matRangeDatepickerContentBase(_elementRef) {
        this._elementRef = _elementRef;
    }
    return matRangeDatepickerContentBase;
}());
export { matRangeDatepickerContentBase };
function matRangeDatepickerContentBase_tsickle_Closure_declarations() {
    /** @type {?} */
    matRangeDatepickerContentBase.prototype._elementRef;
}
export var /** @type {?} */ _matRangeDatepickerContentMixinBase = mixinColor(matRangeDatepickerContentBase);
/**
 * Component used as the content for the datepicker dialog and popup. We use this instead of using
 * SatCalendar directly as the content so we can control the initial focus. This also gives us a
 * place to put additional features of the popup that are not part of the calendar itself in the
 * future. (e.g. confirmation buttons).
 * \@docs-private
 * @template D
 */
var matRangeDatepickerContent = /** @class */ (function (_super) {
    tslib_1.__extends(matRangeDatepickerContent, _super);
    /**
     * @param {?} elementRef
     * @param {?} _changeDetectorRef
     * @param {?} _ngZone
     */
    function matRangeDatepickerContent(elementRef, _changeDetectorRef, _ngZone) {
        var _this = _super.call(this, elementRef) || this;
        _this._changeDetectorRef = _changeDetectorRef;
        _this._ngZone = _ngZone;
        return _this;
    }
    /**
     * @return {?}
     */
    matRangeDatepickerContent.prototype.ngOnInit = function () {
        var _this = this;
        if (!this.datepicker._popupRef || this._positionChange) {
            return;
        }
        var /** @type {?} */ positionStrategy = (((this.datepicker._popupRef.getConfig().positionStrategy)));
        this._positionChange = positionStrategy.positionChanges.subscribe(function (change) {
            var /** @type {?} */ isAbove = change.connectionPair.overlayY === 'bottom';
            if (isAbove !== _this._isAbove) {
                _this._ngZone.run(function () {
                    _this._isAbove = isAbove;
                    _this._changeDetectorRef.markForCheck();
                });
            }
        });
    };
    /**
     * @return {?}
     */
    matRangeDatepickerContent.prototype.ngAfterViewInit = function () {
        // this._calendar.focusActiveCell();
    };
    /**
     * @return {?}
     */
    matRangeDatepickerContent.prototype.ngOnDestroy = function () {
        if (this._positionChange) {
            this._positionChange.unsubscribe();
            this._positionChange = null;
        }
    };
    return matRangeDatepickerContent;
}(_matRangeDatepickerContentMixinBase));
export { matRangeDatepickerContent };
matRangeDatepickerContent.decorators = [
    { type: Component, args: [{
                moduleId: module.id,
                selector: 'mat-range-datepicker-content',
                template: "<range-calendar cdkTrapFocus\n              [id]=\"datepicker.id\"\n              [ngClass]=\"datepicker.panelClass\"\n              [startAt]=\"datepicker.startAt\"\n              [startView]=\"datepicker.startView\"\n              [minDate]=\"datepicker._minDate\"\n              [maxDate]=\"datepicker._maxDate\"\n              [dateFilter]=\"datepicker._dateFilter\"\n              [beginDate]=\"datepicker._beginDate\"\n              [endDate]=\"datepicker._endDate\"\n              [rangeMode]=\"datepicker.rangeMode\"\n              [selected]=\"datepicker._selected\"\n              (selectedChange)=\"datepicker._select($event)\"\n              (dateRangesChange)=\"datepicker._selectRange($event)\"\n              (yearSelected)=\"datepicker._selectYear($event)\"\n              (monthSelected)=\"datepicker._selectMonth($event)\"\n              (_userSelection)=\"datepicker.close($event)\">\n</range-calendar>\n",
                styles: [".mat-datepicker-content{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);display:block;width:593px;height:493px}.end-date-sec,.from-date-sec{display:inline-block;width:50%;height:360px;box-sizing:border-box}.from-date-sec{border-right:.5px solid #e9e9e9}.end-date-sec{border-left:0 solid #e9e9e9}.quick-select-sec{border-top:1px solid #e9e9e9;border-bottom:1px solid #e9e9e9;height:50px;line-height:50px;padding:0 20px;font-size:14px;font-weight:200}.quick-select-sec .select-title{color:#9f9f9f}.quick-select-sec ul{display:inline-block;list-style-type:none;margin:0;color:#696969}.quick-select-sec ul li{display:inline-block;margin-left:10px}.quick-select-sec ul li .mat-button{font-size:13px;font-weight:400}.calendar-button-sec{padding:0 20px;text-align:right;line-height:80px}.calendar-button-sec button{margin-left:10px}.mat-datepicker-content-touch{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-semi-selected),.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-semi-selected),:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-semi-selected){background-color:rgba(0,0,0,.04)}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-semi-selected,.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-semi-selected,:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-semi-selected{background-color:#3f51b5;color:#fff}.mat-calendar-body-begin-range:not(.mat-calendar-body-end-range){border-radius:100% 0 0 100%;background-color:#e8eaf6}.mat-calendar-body-end-range:not(.mat-calendar-body-begin-range){border-radius:0 100% 100% 0;background-color:#e8eaf6}.mat-calendar-body>tr .mat-calendar-cell-semi-selected~.mat-calendar-cell-semi-selected{border-radius:0}.mat-calendar-cell-semi-selected{background-color:#f0e7ff}.mat-button.active .mat-button-focus-overlay{opacity:1}"],
                host: {
                    'class': 'mat-datepicker-content',
                    '[@transformPanel]': '"enter"',
                    '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',
                    '[class.mat-datepicker-content-above]': '_isAbove',
                },
                animations: [
                    matDatepickerAnimations.transformPanel,
                    matDatepickerAnimations.fadeInCalendar,
                ],
                exportAs: 'matDatepickerContent',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                inputs: ['color'],
            },] },
];
/** @nocollapse */
matRangeDatepickerContent.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
    { type: NgZone, },
]; };
matRangeDatepickerContent.propDecorators = {
    "_calendar": [{ type: ViewChild, args: [RangeCalendar,] },],
};
function matRangeDatepickerContent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    matRangeDatepickerContent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    matRangeDatepickerContent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    matRangeDatepickerContent.propDecorators;
    /**
     * Subscription to changes in the overlay's position.
     * @type {?}
     */
    matRangeDatepickerContent.prototype._positionChange;
    /**
     * Reference to the internal calendar component.
     * @type {?}
     */
    matRangeDatepickerContent.prototype._calendar;
    /**
     * Reference to the datepicker that created the overlay.
     * @type {?}
     */
    matRangeDatepickerContent.prototype.datepicker;
    /**
     * Whether the datepicker is above or below the input.
     * @type {?}
     */
    matRangeDatepickerContent.prototype._isAbove;
    /** @type {?} */
    matRangeDatepickerContent.prototype._changeDetectorRef;
    /** @type {?} */
    matRangeDatepickerContent.prototype._ngZone;
}
/**
 * Component responsible for managing the datepicker popup/dialog.
 * @template D
 */
var matRangeDatepicker = /** @class */ (function () {
    /**
     * @param {?} _dialog
     * @param {?} _overlay
     * @param {?} _ngZone
     * @param {?} _viewContainerRef
     * @param {?} _scrollStrategy
     * @param {?} _dateAdapter
     * @param {?} _dir
     * @param {?} _document
     */
    function matRangeDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, _scrollStrategy, _dateAdapter, _dir, _document) {
        this._dialog = _dialog;
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._viewContainerRef = _viewContainerRef;
        this._scrollStrategy = _scrollStrategy;
        this._dateAdapter = _dateAdapter;
        this._dir = _dir;
        this._document = _document;
        /**
         * The view that the calendar should start in.
         */
        this.startView = 'month';
        this._touchUi = false;
        /**
         * Emits selected year in multiyear view.
         * This doesn't imply a change on the selected date.
         */
        this.yearSelected = new EventEmitter();
        /**
         * Emits selected month in year view.
         * This doesn't imply a change on the selected date.
         */
        this.monthSelected = new EventEmitter();
        /**
         * Emits when the datepicker has been opened.
         */
        this.openedStream = new EventEmitter();
        /**
         * Emits when the datepicker has been closed.
         */
        this.closedStream = new EventEmitter();
        this._opened = false;
        /**
         * The id for the datepicker calendar.
         */
        this.id = "mat-range-datepicker-" + datepickerUid++;
        this._validSelected = null;
        /**
         * The element that was focused before the datepicker was opened.
         */
        this._focusedElementBeforeOpen = null;
        /**
         * Subscription to value changes in the associated input element.
         */
        this._inputSubscription = Subscription.EMPTY;
        /**
         * Emits when the datepicker is disabled.
         */
        this._disabledChange = new Subject();
        /**
         * Emits new selected date when selected date changes.
         */
        this._selectedChanged = new Subject();
        if (!this._dateAdapter) {
            throw createMissingDateImplError('DateAdapter');
        }
    }
    Object.defineProperty(matRangeDatepicker.prototype, "rangeMode", {
        /**
         * Whenever datepicker is for selecting range of dates.
         * @return {?}
         */
        get: function () {
            return this._rangeMode;
        },
        /**
         * @param {?} mode
         * @return {?}
         */
        set: function (mode) {
            this._rangeMode = mode;
            if (this.rangeMode) {
                this._validSelected = null;
            }
            else {
                this._beginDate = this._endDate = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "beginDate", {
        /**
         * Start of dates interval.
         * @return {?}
         */
        get: function () { return this._beginDate; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._validSelected = null;
            this._beginDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "endDate", {
        /**
         * End of dates interval.
         * @return {?}
         */
        get: function () { return this._endDate; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._validSelected = null;
            this._endDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "startAt", {
        /**
         * The date to open the calendar to initially.
         * @return {?}
         */
        get: function () {
            // If an explicit startAt is set we start there, otherwise we start at whatever the currently
            // selected value is.
            if (this.rangeMode) {
                return this._startAt || (this._datepickerInput && this._datepickerInput.value ?
                    ((this._datepickerInput.value)).begin : null);
            }
            return this._startAt || (this._datepickerInput ? /** @type {?} */ (this._datepickerInput.value) : null);
        },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "color", {
        /**
         * Color palette to use on the datepicker's calendar.
         * @return {?}
         */
        get: function () {
            return this._color ||
                (this._datepickerInput ? this._datepickerInput._getThemePalette() : undefined);
        },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "touchUi", {
        /**
         * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
         * than a popup and elements have more padding to allow for bigger touch targets.
         * @return {?}
         */
        get: function () { return this._touchUi; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._touchUi = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "disabled", {
        /**
         * Whether the datepicker pop-up should be disabled.
         * @return {?}
         */
        get: function () {
            return this._disabled === undefined && this._datepickerInput ?
                this._datepickerInput.disabled : !!this._disabled;
        },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            var /** @type {?} */ newValue = coerceBooleanProperty(value);
            if (newValue !== this._disabled) {
                this._disabled = newValue;
                this._disabledChange.next(newValue);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "opened", {
        /**
         * Whether the calendar is open.
         * @return {?}
         */
        get: function () { return this._opened; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) { value ? this.open() : this.close(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "_selected", {
        /**
         * The currently selected date.
         * @return {?}
         */
        get: function () { return this._validSelected; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) { this._validSelected = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "_minDate", {
        /**
         * The minimum selectable date.
         * @return {?}
         */
        get: function () {
            return this._datepickerInput && this._datepickerInput.min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "_maxDate", {
        /**
         * The maximum selectable date.
         * @return {?}
         */
        get: function () {
            return this._datepickerInput && this._datepickerInput.max;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepicker.prototype, "_dateFilter", {
        /**
         * @return {?}
         */
        get: function () {
            return this._datepickerInput && this._datepickerInput._dateFilter;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    matRangeDatepicker.prototype.ngAfterContentInit = function () {
        this._initBeginDate = this.beginDate;
        this._initEndDate = this.endDate;
    };
    /**
     * @return {?}
     */
    matRangeDatepicker.prototype.ngOnDestroy = function () {
        this.close();
        this._inputSubscription.unsubscribe();
        this._disabledChange.complete();
        if (this._popupRef) {
            this._popupRef.dispose();
            this._popupComponentRef = null;
        }
    };
    /**
     * Selects the given date
     * @param {?} date
     * @return {?}
     */
    matRangeDatepicker.prototype._select = function (date) {
        var /** @type {?} */ oldValue = this._selected;
        this._selected = date;
        if (!this._dateAdapter.sameDate(oldValue, this._selected)) {
            this._selectedChanged.next(date);
        }
    };
    /**
     * Selects the given date range
     * @param {?} dates
     * @return {?}
     */
    matRangeDatepicker.prototype._selectRange = function (dates) {
        if (!this._dateAdapter.sameDate(dates.begin, this.beginDate) ||
            !this._dateAdapter.sameDate(dates.end, this.endDate)) {
            this._selectedChanged.next(dates);
        }
        this._beginDate = dates.begin;
        this._endDate = dates.end;
    };
    /**
     * Emits the selected year in multiyear view
     * @param {?} normalizedYear
     * @return {?}
     */
    matRangeDatepicker.prototype._selectYear = function (normalizedYear) {
        this.yearSelected.emit(normalizedYear);
    };
    /**
     * Emits selected month in year view
     * @param {?} normalizedMonth
     * @return {?}
     */
    matRangeDatepicker.prototype._selectMonth = function (normalizedMonth) {
        this.monthSelected.emit(normalizedMonth);
    };
    /**
     * Register an input with this datepicker.
     * @param {?} input The datepicker input to register with this datepicker.
     * @return {?}
     */
    matRangeDatepicker.prototype._registerInput = function (input) {
        var _this = this;
        if (this._datepickerInput) {
            throw Error('A matRangeDatepicker can only be associated with a single input.');
        }
        this._datepickerInput = input;
        this._inputSubscription =
            this._datepickerInput._valueChange
                .subscribe(function (value) {
                if (value === null) {
                    _this.beginDate = _this.endDate = _this._selected = null;
                    return;
                }
                if (_this.rangeMode) {
                    value = /** @type {?} */ (value);
                    if (value.begin && value.end &&
                        _this._dateAdapter.compareDate(value.begin, value.end) <= 0) {
                        _this.beginDate = value.begin;
                        _this.endDate = value.end;
                    }
                    else {
                        _this.beginDate = _this.endDate = null;
                    }
                }
                else {
                    _this._selected = /** @type {?} */ (value);
                }
            });
    };
    /**
     * Open the calendar.
     * @return {?}
     */
    matRangeDatepicker.prototype.open = function () {
        this._initBeginDate = this.beginDate;
        this._initEndDate = this.endDate;
        if (this._opened || this.disabled) {
            return;
        }
        if (!this._datepickerInput) {
            throw Error('Attempted to open an matRangeDatepicker with no associated input.');
        }
        if (this._document) {
            this._focusedElementBeforeOpen = this._document.activeElement;
        }
        this.touchUi ? this._openAsDialog() : this._openAsPopup();
        this._opened = true;
        this.openedStream.emit();
    };
    /**
     * Close the calendar.
     * @param {?=} options
     * @return {?}
     */
    matRangeDatepicker.prototype.close = function (options) {
        var _this = this;
        if (!this._opened) {
            return;
        }
        if (this._popupRef && this._popupRef.hasAttached()) {
            this._popupRef.detach();
        }
        if (this._dialogRef) {
            this._dialogRef.close();
            this._dialogRef = null;
        }
        if (this._calendarPortal && this._calendarPortal.isAttached) {
            this._calendarPortal.detach();
        }
        //restore if not applied
        if (!options || !options.apply) {
            this.beginDate = this._initBeginDate;
            this.endDate = this._initEndDate;
            this._selectedChanged.next({
                begin: this.beginDate,
                end: this.endDate,
            });
        }
        var /** @type {?} */ completeClose = function () {
            // The `_opened` could've been reset already if
            // we got two events in quick succession.
            if (_this._opened) {
                _this._opened = false;
                _this.closedStream.emit();
                _this._focusedElementBeforeOpen = null;
            }
        };
        if (this._focusedElementBeforeOpen &&
            typeof this._focusedElementBeforeOpen.focus === 'function') {
            // Because IE moves focus asynchronously, we can't count on it being restored before we've
            // marked the datepicker as closed. If the event fires out of sequence and the element that
            // we're refocusing opens the datepicker on focus, the user could be stuck with not being
            // able to close the calendar at all. We work around it by making the logic, that marks
            // the datepicker as closed, async as well.
            this._focusedElementBeforeOpen.focus();
            setTimeout(completeClose);
        }
        else {
            completeClose();
        }
    };
    /**
     * Open the calendar as a dialog.
     * @return {?}
     */
    matRangeDatepicker.prototype._openAsDialog = function () {
        var _this = this;
        this._dialogRef = this._dialog.open(matRangeDatepickerContent, {
            direction: this._getDirection(),
            viewContainerRef: this._viewContainerRef,
            panelClass: 'mat-datepicker-dialog',
        });
        this._dialogRef.afterClosed().subscribe(function () { return _this.close(); });
        this._dialogRef.componentInstance.datepicker = this;
        this._setColor();
    };
    /**
     * Open the calendar as a popup.
     * @return {?}
     */
    matRangeDatepicker.prototype._openAsPopup = function () {
        var _this = this;
        if (!this._calendarPortal) {
            this._calendarPortal = new ComponentPortal(matRangeDatepickerContent, this._viewContainerRef);
        }
        if (!this._popupRef) {
            this._createPopup();
        }
        if (!this._popupRef.hasAttached()) {
            this._popupRef.setDirection(this._getDirection());
            this._popupComponentRef = this._popupRef.attach(this._calendarPortal);
            this._popupComponentRef.instance.datepicker = this;
            this._setColor();
            // Update the position once the calendar has rendered.
            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {
                _this._popupRef.updatePosition();
            });
        }
    };
    /**
     * Create the popup.
     * @return {?}
     */
    matRangeDatepicker.prototype._createPopup = function () {
        var _this = this;
        var /** @type {?} */ overlayConfig = new OverlayConfig({
            positionStrategy: this._createPopupPositionStrategy(),
            hasBackdrop: true,
            backdropClass: 'mat-overlay-transparent-backdrop',
            direction: this._getDirection(),
            scrollStrategy: this._scrollStrategy(),
            panelClass: 'mat-datepicker-popup',
        });
        this._popupRef = this._overlay.create(overlayConfig);
        merge(this._popupRef.backdropClick(), 
        // this._popupRef.detachments(),
        this._popupRef.keydownEvents().pipe(filter(function (event) {
            // Closing on alt + up is only valid when there's an input associated with the datepicker.
            return event.keyCode === ESCAPE ||
                (_this._datepickerInput && event.altKey && event.keyCode === UP_ARROW);
        }))).subscribe(function () { return _this.close(); });
    };
    /**
     * Create the popup PositionStrategy.
     * @return {?}
     */
    matRangeDatepicker.prototype._createPopupPositionStrategy = function () {
        return this._overlay.position()
            .flexibleConnectedTo(this._datepickerInput.getPopupConnectionElementRef())
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withPush(false)
            .withPositions([
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top'
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom'
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'top'
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'bottom'
            }
        ]);
    };
    /**
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    matRangeDatepicker.prototype._getValidDateOrNull = function (obj) {
        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
    };
    /**
     * Passes the current theme color along to the calendar overlay.
     * @return {?}
     */
    matRangeDatepicker.prototype._setColor = function () {
        var /** @type {?} */ color = this.color;
        if (this._popupComponentRef) {
            this._popupComponentRef.instance.color = color;
        }
        if (this._dialogRef) {
            this._dialogRef.componentInstance.color = color;
        }
    };
    /**
     * Returns the layout direction of the datepicker.
     * @return {?}
     */
    matRangeDatepicker.prototype._getDirection = function () {
        return this._dir ? this._dir.value : 'ltr';
    };
    return matRangeDatepicker;
}());
export { matRangeDatepicker };
matRangeDatepicker.decorators = [
    { type: Component, args: [{
                moduleId: module.id,
                selector: 'mat-range-datepicker',
                template: '',
                exportAs: 'matDatepicker',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
matRangeDatepicker.ctorParameters = function () { return [
    { type: MatDialog, },
    { type: Overlay, },
    { type: NgZone, },
    { type: ViewContainerRef, },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DATEPICKER_SCROLL_STRATEGY,] },] },
    { type: DateAdapter, decorators: [{ type: Optional },] },
    { type: Directionality, decorators: [{ type: Optional },] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] },] },
]; };
matRangeDatepicker.propDecorators = {
    "rangeMode": [{ type: Input },],
    "beginDate": [{ type: Input },],
    "endDate": [{ type: Input },],
    "calendarHeaderComponent": [{ type: Input },],
    "startAt": [{ type: Input },],
    "startView": [{ type: Input },],
    "color": [{ type: Input },],
    "touchUi": [{ type: Input },],
    "disabled": [{ type: Input },],
    "yearSelected": [{ type: Output },],
    "monthSelected": [{ type: Output },],
    "panelClass": [{ type: Input },],
    "openedStream": [{ type: Output, args: ['opened',] },],
    "closedStream": [{ type: Output, args: ['closed',] },],
    "opened": [{ type: Input },],
};
function matRangeDatepicker_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    matRangeDatepicker.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    matRangeDatepicker.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    matRangeDatepicker.propDecorators;
    /** @type {?} */
    matRangeDatepicker.prototype._rangeMode;
    /** @type {?} */
    matRangeDatepicker.prototype._beginDate;
    /** @type {?} */
    matRangeDatepicker.prototype._initBeginDate;
    /** @type {?} */
    matRangeDatepicker.prototype._endDate;
    /** @type {?} */
    matRangeDatepicker.prototype._initEndDate;
    /**
     * An input indicating the type of the custom header component for the calendar, if set.
     * @type {?}
     */
    matRangeDatepicker.prototype.calendarHeaderComponent;
    /** @type {?} */
    matRangeDatepicker.prototype._startAt;
    /**
     * The view that the calendar should start in.
     * @type {?}
     */
    matRangeDatepicker.prototype.startView;
    /** @type {?} */
    matRangeDatepicker.prototype._color;
    /** @type {?} */
    matRangeDatepicker.prototype._touchUi;
    /** @type {?} */
    matRangeDatepicker.prototype._disabled;
    /**
     * Emits selected year in multiyear view.
     * This doesn't imply a change on the selected date.
     * @type {?}
     */
    matRangeDatepicker.prototype.yearSelected;
    /**
     * Emits selected month in year view.
     * This doesn't imply a change on the selected date.
     * @type {?}
     */
    matRangeDatepicker.prototype.monthSelected;
    /**
     * Classes to be passed to the date picker panel. Supports the same syntax as `ngClass`.
     * @type {?}
     */
    matRangeDatepicker.prototype.panelClass;
    /**
     * Emits when the datepicker has been opened.
     * @type {?}
     */
    matRangeDatepicker.prototype.openedStream;
    /**
     * Emits when the datepicker has been closed.
     * @type {?}
     */
    matRangeDatepicker.prototype.closedStream;
    /** @type {?} */
    matRangeDatepicker.prototype._opened;
    /**
     * The id for the datepicker calendar.
     * @type {?}
     */
    matRangeDatepicker.prototype.id;
    /** @type {?} */
    matRangeDatepicker.prototype._validSelected;
    /**
     * A reference to the overlay when the calendar is opened as a popup.
     * @type {?}
     */
    matRangeDatepicker.prototype._popupRef;
    /**
     * A reference to the dialog when the calendar is opened as a dialog.
     * @type {?}
     */
    matRangeDatepicker.prototype._dialogRef;
    /**
     * A portal containing the calendar for this datepicker.
     * @type {?}
     */
    matRangeDatepicker.prototype._calendarPortal;
    /**
     * Reference to the component instantiated in popup mode.
     * @type {?}
     */
    matRangeDatepicker.prototype._popupComponentRef;
    /**
     * The element that was focused before the datepicker was opened.
     * @type {?}
     */
    matRangeDatepicker.prototype._focusedElementBeforeOpen;
    /**
     * Subscription to value changes in the associated input element.
     * @type {?}
     */
    matRangeDatepicker.prototype._inputSubscription;
    /**
     * The input element this datepicker is associated with.
     * @type {?}
     */
    matRangeDatepicker.prototype._datepickerInput;
    /**
     * Emits when the datepicker is disabled.
     * @type {?}
     */
    matRangeDatepicker.prototype._disabledChange;
    /**
     * Emits new selected date when selected date changes.
     * @type {?}
     */
    matRangeDatepicker.prototype._selectedChanged;
    /** @type {?} */
    matRangeDatepicker.prototype._dialog;
    /** @type {?} */
    matRangeDatepicker.prototype._overlay;
    /** @type {?} */
    matRangeDatepicker.prototype._ngZone;
    /** @type {?} */
    matRangeDatepicker.prototype._viewContainerRef;
    /** @type {?} */
    matRangeDatepicker.prototype._scrollStrategy;
    /** @type {?} */
    matRangeDatepicker.prototype._dateAdapter;
    /** @type {?} */
    matRangeDatepicker.prototype._dir;
    /** @type {?} */
    matRangeDatepicker.prototype._document;
}
//# sourceMappingURL=datepicker.js.map
