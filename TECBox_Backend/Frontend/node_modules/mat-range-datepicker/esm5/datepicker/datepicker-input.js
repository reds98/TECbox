/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { DOWN_ARROW } from '@angular/cdk/keycodes';
import { Directive, ElementRef, EventEmitter, forwardRef, Inject, Input, Optional, Output, } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import { DateAdapter } from '../datetime/date-adapter';
import { MAT_DATE_FORMATS } from '../datetime/date-formats';
import { MatFormField } from '@angular/material/form-field';
import { MAT_INPUT_VALUE_ACCESSOR } from '@angular/material/input';
import { Subscription } from 'rxjs';
import { createMissingDateImplError } from './datepicker-errors';
export var /** @type {?} */ MAT_DATEPICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return matRangeDatepickerInput; }),
    multi: true
};
export var /** @type {?} */ MAT_DATEPICKER_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(function () { return matRangeDatepickerInput; }),
    multi: true
};
/**
 * Special interface to input and output dates interval.
 * @record
 * @template D
 */
export function matRangeDatepickerRangeValue() { }
function matRangeDatepickerRangeValue_tsickle_Closure_declarations() {
    /** @type {?} */
    matRangeDatepickerRangeValue.prototype.begin;
    /** @type {?} */
    matRangeDatepickerRangeValue.prototype.end;
}
/**
 * An event used for datepicker input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use matRangeDatepickerInputEvent instead.
 * @template D
 */
var matRangeDatepickerInputEvent = /** @class */ (function () {
    /**
     * @param {?} target
     * @param {?} targetElement
     */
    function matRangeDatepickerInputEvent(target, targetElement) {
        this.target = target;
        this.targetElement = targetElement;
        this.value = this.target.value;
    }
    return matRangeDatepickerInputEvent;
}());
export { matRangeDatepickerInputEvent };
function matRangeDatepickerInputEvent_tsickle_Closure_declarations() {
    /**
     * The new value for the target datepicker input.
     * @type {?}
     */
    matRangeDatepickerInputEvent.prototype.value;
    /**
     * Reference to the datepicker input component that emitted the event.
     * @type {?}
     */
    matRangeDatepickerInputEvent.prototype.target;
    /**
     * Reference to the native input element associated with the datepicker input.
     * @type {?}
     */
    matRangeDatepickerInputEvent.prototype.targetElement;
}
/**
 * Directive used to connect an input to a matRangeDatepicker.
 * @template D
 */
var matRangeDatepickerInput = /** @class */ (function () {
    /**
     * @param {?} _elementRef
     * @param {?} _dateAdapter
     * @param {?} _dateFormats
     * @param {?} _formField
     */
    function matRangeDatepickerInput(_elementRef, _dateAdapter, _dateFormats, _formField) {
        var _this = this;
        this._elementRef = _elementRef;
        this._dateAdapter = _dateAdapter;
        this._dateFormats = _dateFormats;
        this._formField = _formField;
        /**
         * Emits when a `change` event is fired on this `<input>`.
         */
        this.dateChange = new EventEmitter();
        /**
         * Emits when an `input` event is fired on this `<input>`.
         */
        this.dateInput = new EventEmitter();
        /**
         * Emits when the value changes (either due to user input or programmatic change).
         */
        this._valueChange = new EventEmitter();
        /**
         * Emits when the disabled state has changed
         */
        this._disabledChange = new EventEmitter();
        this._onTouched = function () { };
        this._cvaOnChange = function () { };
        this._validatorOnChange = function () { };
        this._datepickerSubscription = Subscription.EMPTY;
        this._localeSubscription = Subscription.EMPTY;
        /**
         * The form control validator for whether the input parses.
         */
        this._parseValidator = function () {
            return _this._lastValueValid ?
                null : { 'matDatepickerParse': { 'text': _this._elementRef.nativeElement.value } };
        };
        /**
         * The form control validator for the min date.
         */
        this._minValidator = function (control) {
            if (_this._datepicker.rangeMode && control.value) {
                var /** @type {?} */ beginDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.begin));
                var /** @type {?} */ endDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.end));
                if (_this.min) {
                    if (beginDate && _this._dateAdapter.compareDate(_this.min, beginDate) > 0) {
                        return { 'matDatepickerMin': { 'min': _this.min, 'actual': beginDate } };
                    }
                    if (endDate && _this._dateAdapter.compareDate(_this.min, endDate) > 0) {
                        return { 'matDatepickerMin': { 'min': _this.min, 'actual': endDate } };
                    }
                }
                return null;
            }
            var /** @type {?} */ controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
            return (!_this.min || !controlValue ||
                _this._dateAdapter.compareDate(_this.min, controlValue) <= 0) ?
                null : { 'matDatepickerMin': { 'min': _this.min, 'actual': controlValue } };
        };
        /**
         * The form control validator for the max date.
         */
        this._maxValidator = function (control) {
            if (_this._datepicker.rangeMode && control.value) {
                var /** @type {?} */ beginDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.begin));
                var /** @type {?} */ endDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.end));
                if (_this.max) {
                    if (beginDate && _this._dateAdapter.compareDate(_this.max, beginDate) < 0) {
                        return { 'matDatepickerMax': { 'max': _this.max, 'actual': beginDate } };
                    }
                    if (endDate && _this._dateAdapter.compareDate(_this.max, endDate) < 0) {
                        return { 'matDatepickerMax': { 'max': _this.max, 'actual': endDate } };
                    }
                }
                return null;
            }
            var /** @type {?} */ controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
            return (!_this.max || !controlValue ||
                _this._dateAdapter.compareDate(_this.max, controlValue) >= 0) ?
                null : { 'matDatepickerMax': { 'max': _this.max, 'actual': controlValue } };
        };
        /**
         * The form control validator for the date filter.
         */
        this._filterValidator = function (control) {
            if (_this._datepicker.rangeMode && control.value) {
                var /** @type {?} */ beginDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.begin));
                var /** @type {?} */ endDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.end));
                return !_this._dateFilter || !beginDate && !endDate ||
                    _this._dateFilter(beginDate) && _this._dateFilter(endDate) ?
                    null : { 'matDatepickerFilter': true };
            }
            var /** @type {?} */ controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
            return !_this._dateFilter || !controlValue || _this._dateFilter(controlValue) ?
                null : { 'matDatepickerFilter': true };
        };
        /**
         * The form control validator for the date filter.
         */
        this._rangeValidator = function (control) {
            if (_this._datepicker.rangeMode && control.value) {
                var /** @type {?} */ beginDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.begin));
                var /** @type {?} */ endDate = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value.end));
                return !beginDate || !endDate || _this._dateAdapter.compareDate(beginDate, endDate) <= 0 ?
                    null : { 'matDatepickerRange': true };
            }
            return null;
        };
        /**
         * The combined form control validator for this input.
         */
        this._validator = Validators.compose([this._parseValidator, this._minValidator, this._maxValidator,
            this._filterValidator, this._rangeValidator]);
        /**
         * Whether the last value set on the input was valid.
         */
        this._lastValueValid = false;
        if (!this._dateAdapter) {
            throw createMissingDateImplError('DateAdapter');
        }
        if (!this._dateFormats) {
            throw createMissingDateImplError('MAT_DATE_FORMATS');
        }
        // Update the displayed date when the locale changes.
        this._localeSubscription = _dateAdapter.localeChanges.subscribe(function () {
            _this.value = _this.value;
        });
    }
    Object.defineProperty(matRangeDatepickerInput.prototype, "matRangeDatepicker", {
        /**
         * The datepicker that this input is associated with.
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this.registerDatepicker(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    matRangeDatepickerInput.prototype.registerDatepicker = function (value) {
        if (value) {
            this._datepicker = value;
            this._datepicker._registerInput(this);
        }
    };
    Object.defineProperty(matRangeDatepickerInput.prototype, "matDatepickerFilter", {
        /**
         * Function that can be used to filter out dates within the datepicker.
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._dateFilter = value;
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepickerInput.prototype, "value", {
        /**
         * The value of the input.
         * @return {?}
         */
        get: function () {
            return this._value;
        },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            if (value && value.hasOwnProperty('begin') && value.hasOwnProperty('end')) {
                /**
                 * Range mode
                 */
                var /** @type {?} */ rangeValue = (value);
                rangeValue.begin = this._dateAdapter.deserialize(rangeValue.begin);
                rangeValue.end = this._dateAdapter.deserialize(rangeValue.end);
                this._lastValueValid = !rangeValue.begin || !rangeValue.end ||
                    this._dateAdapter.isValid(rangeValue.begin) && this._dateAdapter.isValid(rangeValue.end);
                rangeValue.begin = this._getValidDateOrNull(rangeValue.begin);
                rangeValue.end = this._getValidDateOrNull(rangeValue.end);
                var /** @type {?} */ oldDate = (this.value);
                this._elementRef.nativeElement.value =
                    rangeValue && rangeValue.begin && rangeValue.end
                        ? this._dateAdapter.format(rangeValue.begin, this._dateFormats.display.dateInput) +
                            ' - ' +
                            this._dateAdapter.format(rangeValue.end, this._dateFormats.display.dateInput)
                        : '';
                if (oldDate == null && rangeValue != null || oldDate != null && rangeValue == null ||
                    !this._dateAdapter.sameDate(((oldDate)).begin, rangeValue.begin) ||
                    !this._dateAdapter.sameDate(((oldDate)).end, rangeValue.end)) {
                    if (rangeValue.end && rangeValue.begin &&
                        this._dateAdapter
                            .compareDate(rangeValue.begin, rangeValue.end) > 0) {
                        // if begin > end
                        value = null;
                    }
                    this._value = value;
                    this._valueChange.emit(value);
                }
            }
            else {
                /** Not range mode */
                value = this._dateAdapter.deserialize(value);
                this._lastValueValid = !value || this._dateAdapter.isValid(value);
                value = this._getValidDateOrNull(value);
                var /** @type {?} */ oldDate = this.value;
                this._value = value;
                this._elementRef.nativeElement.value =
                    value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
                if (!this._dateAdapter.sameDate(/** @type {?} */ (oldDate), value)) {
                    this._valueChange.emit(value);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepickerInput.prototype, "min", {
        /**
         * The minimum valid date.
         * @return {?}
         */
        get: function () { return this._min; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepickerInput.prototype, "max", {
        /**
         * The maximum valid date.
         * @return {?}
         */
        get: function () { return this._max; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(matRangeDatepickerInput.prototype, "disabled", {
        /**
         * Whether the datepicker-input is disabled.
         * @return {?}
         */
        get: function () { return !!this._disabled; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            var /** @type {?} */ newValue = coerceBooleanProperty(value);
            var /** @type {?} */ element = this._elementRef.nativeElement;
            if (this._disabled !== newValue) {
                this._disabled = newValue;
                this._disabledChange.emit(newValue);
            }
            // We need to null check the `blur` method, because it's undefined during SSR.
            if (newValue && element.blur) {
                // Normally, native input elements automatically blur if they turn disabled. This behavior
                // is problematic, because it would mean that it triggers another change detection cycle,
                // which then causes a changed after checked error if the input element was focused before.
                element.blur();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    matRangeDatepickerInput.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (this._datepicker) {
            this._datepickerSubscription =
                this._datepicker._selectedChanged.subscribe(function (selected) {
                    _this.value = selected;
                    _this._cvaOnChange(selected);
                    _this._onTouched();
                    _this.dateInput.emit(new matRangeDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                    _this.dateChange.emit(new matRangeDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                });
        }
    };
    /**
     * @return {?}
     */
    matRangeDatepickerInput.prototype.ngOnDestroy = function () {
        this._datepickerSubscription.unsubscribe();
        this._localeSubscription.unsubscribe();
        this._valueChange.complete();
        this._disabledChange.complete();
    };
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    matRangeDatepickerInput.prototype.registerOnValidatorChange = function (fn) {
        this._validatorOnChange = fn;
    };
    /**
     * \@docs-private
     * @param {?} c
     * @return {?}
     */
    matRangeDatepickerInput.prototype.validate = function (c) {
        return this._validator ? this._validator(c) : null;
    };
    /**
     * @deprecated
     * \@deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead
     * @return {?}
     */
    matRangeDatepickerInput.prototype.getPopupConnectionElementRef = function () {
        return this.getConnectedOverlayOrigin();
    };
    /**
     * Gets the element that the datepicker popup should be connected to.
     * @return {?} The element to connect the popup to.
     */
    matRangeDatepickerInput.prototype.getConnectedOverlayOrigin = function () {
        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    matRangeDatepickerInput.prototype.writeValue = function (value) {
        this.value = value;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    matRangeDatepickerInput.prototype.registerOnChange = function (fn) {
        this._cvaOnChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    matRangeDatepickerInput.prototype.registerOnTouched = function (fn) {
        this._onTouched = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    matRangeDatepickerInput.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    matRangeDatepickerInput.prototype._onKeydown = function (event) {
        if (event.altKey && event.keyCode === DOWN_ARROW) {
            this._datepicker.open();
            event.preventDefault();
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    matRangeDatepickerInput.prototype._onInput = function (value) {
        var /** @type {?} */ date = null;
        if (this._datepicker.rangeMode) {
            var /** @type {?} */ parts = value.split('-');
            if (parts.length > 1) {
                var /** @type {?} */ position = Math.floor(parts.length / 2);
                var /** @type {?} */ beginDateString = parts.slice(0, position).join('-');
                var /** @type {?} */ endDateString = parts.slice(position).join('-');
                var /** @type {?} */ beginDate = this._dateAdapter.parse(beginDateString, this._dateFormats.parse.dateInput);
                var /** @type {?} */ endDate = this._dateAdapter.parse(endDateString, this._dateFormats.parse.dateInput);
                this._lastValueValid = !beginDate || !endDate || this._dateAdapter.isValid(beginDate) &&
                    this._dateAdapter.isValid(endDate);
                beginDate = this._getValidDateOrNull(beginDate);
                endDate = this._getValidDateOrNull(endDate);
                if (beginDate && endDate) {
                    date = /** @type {?} */ ({ begin: beginDate, end: endDate });
                }
            }
        }
        else {
            date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);
            this._lastValueValid = !date || this._dateAdapter.isValid(date);
            date = this._getValidDateOrNull(date);
        }
        this._value = date;
        this._cvaOnChange(date);
        this._valueChange.emit(date);
        this.dateInput.emit(new matRangeDatepickerInputEvent(this, this._elementRef.nativeElement));
    };
    /**
     * @return {?}
     */
    matRangeDatepickerInput.prototype._onChange = function () {
        this.dateChange.emit(new matRangeDatepickerInputEvent(this, this._elementRef.nativeElement));
    };
    /**
     * Returns the palette used by the input's form field, if any.
     * @return {?}
     */
    matRangeDatepickerInput.prototype._getThemePalette = function () {
        return this._formField ? this._formField.color : undefined;
    };
    /**
     * Handles blur events on the input.
     * @return {?}
     */
    matRangeDatepickerInput.prototype._onBlur = function () {
        // Reformat the input only if we have a valid value.
        if (this.value) {
            this._formatValue(this.value);
        }
        this._onTouched();
    };
    /**
     * Formats a value and sets it on the input element.
     * @param {?} value
     * @return {?}
     */
    matRangeDatepickerInput.prototype._formatValue = function (value) {
        if (value && value.hasOwnProperty('begin') && value.hasOwnProperty('end')) {
            value = /** @type {?} */ (value);
            this._elementRef.nativeElement.value =
                value && value.begin && value.end
                    ? this._dateAdapter.format(value.begin, this._dateFormats.display.dateInput) +
                        ' - ' +
                        this._dateAdapter.format(value.end, this._dateFormats.display.dateInput)
                    : '';
        }
        else {
            value = /** @type {?} */ (value);
            this._elementRef.nativeElement.value =
                value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
        }
    };
    /**
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    matRangeDatepickerInput.prototype._getValidDateOrNull = function (obj) {
        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
    };
    return matRangeDatepickerInput;
}());
export { matRangeDatepickerInput };
matRangeDatepickerInput.decorators = [
    { type: Directive, args: [{
                selector: 'input[matRangeDatepicker]',
                providers: [
                    MAT_DATEPICKER_VALUE_ACCESSOR,
                    MAT_DATEPICKER_VALIDATORS,
                    { provide: MAT_INPUT_VALUE_ACCESSOR, useExisting: matRangeDatepickerInput },
                ],
                host: {
                    '[attr.aria-haspopup]': 'true',
                    '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',
                    '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',
                    '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',
                    '[disabled]': 'disabled',
                    '(input)': '_onInput($event.target.value)',
                    '(change)': '_onChange()',
                    '(blur)': '_onBlur()',
                    '(keydown)': '_onKeydown($event)',
                },
                exportAs: 'matDatepickerInput',
            },] },
];
/** @nocollapse */
matRangeDatepickerInput.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: DateAdapter, decorators: [{ type: Optional },] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_FORMATS,] },] },
    { type: MatFormField, decorators: [{ type: Optional },] },
]; };
matRangeDatepickerInput.propDecorators = {
    "matRangeDatepicker": [{ type: Input },],
    "matDatepickerFilter": [{ type: Input },],
    "value": [{ type: Input },],
    "min": [{ type: Input },],
    "max": [{ type: Input },],
    "disabled": [{ type: Input },],
    "dateChange": [{ type: Output },],
    "dateInput": [{ type: Output },],
};
function matRangeDatepickerInput_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    matRangeDatepickerInput.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    matRangeDatepickerInput.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    matRangeDatepickerInput.propDecorators;
    /** @type {?} */
    matRangeDatepickerInput.prototype._datepicker;
    /** @type {?} */
    matRangeDatepickerInput.prototype._dateFilter;
    /** @type {?} */
    matRangeDatepickerInput.prototype._value;
    /** @type {?} */
    matRangeDatepickerInput.prototype._min;
    /** @type {?} */
    matRangeDatepickerInput.prototype._max;
    /** @type {?} */
    matRangeDatepickerInput.prototype._disabled;
    /**
     * Emits when a `change` event is fired on this `<input>`.
     * @type {?}
     */
    matRangeDatepickerInput.prototype.dateChange;
    /**
     * Emits when an `input` event is fired on this `<input>`.
     * @type {?}
     */
    matRangeDatepickerInput.prototype.dateInput;
    /**
     * Emits when the value changes (either due to user input or programmatic change).
     * @type {?}
     */
    matRangeDatepickerInput.prototype._valueChange;
    /**
     * Emits when the disabled state has changed
     * @type {?}
     */
    matRangeDatepickerInput.prototype._disabledChange;
    /** @type {?} */
    matRangeDatepickerInput.prototype._onTouched;
    /** @type {?} */
    matRangeDatepickerInput.prototype._cvaOnChange;
    /** @type {?} */
    matRangeDatepickerInput.prototype._validatorOnChange;
    /** @type {?} */
    matRangeDatepickerInput.prototype._datepickerSubscription;
    /** @type {?} */
    matRangeDatepickerInput.prototype._localeSubscription;
    /**
     * The form control validator for whether the input parses.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._parseValidator;
    /**
     * The form control validator for the min date.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._minValidator;
    /**
     * The form control validator for the max date.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._maxValidator;
    /**
     * The form control validator for the date filter.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._filterValidator;
    /**
     * The form control validator for the date filter.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._rangeValidator;
    /**
     * The combined form control validator for this input.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._validator;
    /**
     * Whether the last value set on the input was valid.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._lastValueValid;
    /** @type {?} */
    matRangeDatepickerInput.prototype._elementRef;
    /** @type {?} */
    matRangeDatepickerInput.prototype._dateAdapter;
    /** @type {?} */
    matRangeDatepickerInput.prototype._dateFormats;
    /** @type {?} */
    matRangeDatepickerInput.prototype._formField;
}
//# sourceMappingURL=datepicker-input.js.map
