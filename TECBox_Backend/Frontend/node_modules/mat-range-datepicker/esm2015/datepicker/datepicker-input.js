/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { DOWN_ARROW } from '@angular/cdk/keycodes';
import { Directive, ElementRef, EventEmitter, forwardRef, Inject, Input, Optional, Output, } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import { DateAdapter } from '../datetime/date-adapter';
import { MAT_DATE_FORMATS } from '../datetime/date-formats';
import { MatFormField } from '@angular/material/form-field';
import { MAT_INPUT_VALUE_ACCESSOR } from '@angular/material/input';
import { Subscription } from 'rxjs';
import { matRangeDatepicker } from './datepicker';
import { createMissingDateImplError } from './datepicker-errors';
export const /** @type {?} */ MAT_DATEPICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => matRangeDatepickerInput),
    multi: true
};
export const /** @type {?} */ MAT_DATEPICKER_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => matRangeDatepickerInput),
    multi: true
};
/**
 * Special interface to input and output dates interval.
 * @record
 * @template D
 */
export function matRangeDatepickerRangeValue() { }
function matRangeDatepickerRangeValue_tsickle_Closure_declarations() {
    /** @type {?} */
    matRangeDatepickerRangeValue.prototype.begin;
    /** @type {?} */
    matRangeDatepickerRangeValue.prototype.end;
}
/**
 * An event used for datepicker input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use matRangeDatepickerInputEvent instead.
 * @template D
 */
export class matRangeDatepickerInputEvent {
    /**
     * @param {?} target
     * @param {?} targetElement
     */
    constructor(target, targetElement) {
        this.target = target;
        this.targetElement = targetElement;
        this.value = this.target.value;
    }
}
function matRangeDatepickerInputEvent_tsickle_Closure_declarations() {
    /**
     * The new value for the target datepicker input.
     * @type {?}
     */
    matRangeDatepickerInputEvent.prototype.value;
    /**
     * Reference to the datepicker input component that emitted the event.
     * @type {?}
     */
    matRangeDatepickerInputEvent.prototype.target;
    /**
     * Reference to the native input element associated with the datepicker input.
     * @type {?}
     */
    matRangeDatepickerInputEvent.prototype.targetElement;
}
/**
 * Directive used to connect an input to a matRangeDatepicker.
 * @template D
 */
export class matRangeDatepickerInput {
    /**
     * @param {?} _elementRef
     * @param {?} _dateAdapter
     * @param {?} _dateFormats
     * @param {?} _formField
     */
    constructor(_elementRef, _dateAdapter, _dateFormats, _formField) {
        this._elementRef = _elementRef;
        this._dateAdapter = _dateAdapter;
        this._dateFormats = _dateFormats;
        this._formField = _formField;
        /**
         * Emits when a `change` event is fired on this `<input>`.
         */
        this.dateChange = new EventEmitter();
        /**
         * Emits when an `input` event is fired on this `<input>`.
         */
        this.dateInput = new EventEmitter();
        /**
         * Emits when the value changes (either due to user input or programmatic change).
         */
        this._valueChange = new EventEmitter();
        /**
         * Emits when the disabled state has changed
         */
        this._disabledChange = new EventEmitter();
        this._onTouched = () => { };
        this._cvaOnChange = () => { };
        this._validatorOnChange = () => { };
        this._datepickerSubscription = Subscription.EMPTY;
        this._localeSubscription = Subscription.EMPTY;
        /**
         * The form control validator for whether the input parses.
         */
        this._parseValidator = () => {
            return this._lastValueValid ?
                null : { 'matDatepickerParse': { 'text': this._elementRef.nativeElement.value } };
        };
        /**
         * The form control validator for the min date.
         */
        this._minValidator = (control) => {
            if (this._datepicker.rangeMode && control.value) {
                const /** @type {?} */ beginDate = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value.begin));
                const /** @type {?} */ endDate = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value.end));
                if (this.min) {
                    if (beginDate && this._dateAdapter.compareDate(this.min, beginDate) > 0) {
                        return { 'matDatepickerMin': { 'min': this.min, 'actual': beginDate } };
                    }
                    if (endDate && this._dateAdapter.compareDate(this.min, endDate) > 0) {
                        return { 'matDatepickerMin': { 'min': this.min, 'actual': endDate } };
                    }
                }
                return null;
            }
            const /** @type {?} */ controlValue = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value));
            return (!this.min || !controlValue ||
                this._dateAdapter.compareDate(this.min, controlValue) <= 0) ?
                null : { 'matDatepickerMin': { 'min': this.min, 'actual': controlValue } };
        };
        /**
         * The form control validator for the max date.
         */
        this._maxValidator = (control) => {
            if (this._datepicker.rangeMode && control.value) {
                const /** @type {?} */ beginDate = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value.begin));
                const /** @type {?} */ endDate = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value.end));
                if (this.max) {
                    if (beginDate && this._dateAdapter.compareDate(this.max, beginDate) < 0) {
                        return { 'matDatepickerMax': { 'max': this.max, 'actual': beginDate } };
                    }
                    if (endDate && this._dateAdapter.compareDate(this.max, endDate) < 0) {
                        return { 'matDatepickerMax': { 'max': this.max, 'actual': endDate } };
                    }
                }
                return null;
            }
            const /** @type {?} */ controlValue = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value));
            return (!this.max || !controlValue ||
                this._dateAdapter.compareDate(this.max, controlValue) >= 0) ?
                null : { 'matDatepickerMax': { 'max': this.max, 'actual': controlValue } };
        };
        /**
         * The form control validator for the date filter.
         */
        this._filterValidator = (control) => {
            if (this._datepicker.rangeMode && control.value) {
                const /** @type {?} */ beginDate = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value.begin));
                const /** @type {?} */ endDate = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value.end));
                return !this._dateFilter || !beginDate && !endDate ||
                    this._dateFilter(beginDate) && this._dateFilter(endDate) ?
                    null : { 'matDatepickerFilter': true };
            }
            const /** @type {?} */ controlValue = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value));
            return !this._dateFilter || !controlValue || this._dateFilter(controlValue) ?
                null : { 'matDatepickerFilter': true };
        };
        /**
         * The form control validator for the date filter.
         */
        this._rangeValidator = (control) => {
            if (this._datepicker.rangeMode && control.value) {
                const /** @type {?} */ beginDate = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value.begin));
                const /** @type {?} */ endDate = this._getValidDateOrNull(this._dateAdapter.deserialize(control.value.end));
                return !beginDate || !endDate || this._dateAdapter.compareDate(beginDate, endDate) <= 0 ?
                    null : { 'matDatepickerRange': true };
            }
            return null;
        };
        /**
         * The combined form control validator for this input.
         */
        this._validator = Validators.compose([this._parseValidator, this._minValidator, this._maxValidator,
            this._filterValidator, this._rangeValidator]);
        /**
         * Whether the last value set on the input was valid.
         */
        this._lastValueValid = false;
        if (!this._dateAdapter) {
            throw createMissingDateImplError('DateAdapter');
        }
        if (!this._dateFormats) {
            throw createMissingDateImplError('MAT_DATE_FORMATS');
        }
        // Update the displayed date when the locale changes.
        this._localeSubscription = _dateAdapter.localeChanges.subscribe(() => {
            this.value = this.value;
        });
    }
    /**
     * The datepicker that this input is associated with.
     * @param {?} value
     * @return {?}
     */
    set matRangeDatepicker(value) {
        this.registerDatepicker(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    registerDatepicker(value) {
        if (value) {
            this._datepicker = value;
            this._datepicker._registerInput(this);
        }
    }
    /**
     * Function that can be used to filter out dates within the datepicker.
     * @param {?} value
     * @return {?}
     */
    set matDatepickerFilter(value) {
        this._dateFilter = value;
        this._validatorOnChange();
    }
    /**
     * The value of the input.
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (value && value.hasOwnProperty('begin') && value.hasOwnProperty('end')) {
            /**
             * Range mode
             */
            const /** @type {?} */ rangeValue = /** @type {?} */ (value);
            rangeValue.begin = this._dateAdapter.deserialize(rangeValue.begin);
            rangeValue.end = this._dateAdapter.deserialize(rangeValue.end);
            this._lastValueValid = !rangeValue.begin || !rangeValue.end ||
                this._dateAdapter.isValid(rangeValue.begin) && this._dateAdapter.isValid(rangeValue.end);
            rangeValue.begin = this._getValidDateOrNull(rangeValue.begin);
            rangeValue.end = this._getValidDateOrNull(rangeValue.end);
            let /** @type {?} */ oldDate = /** @type {?} */ (this.value);
            this._elementRef.nativeElement.value =
                rangeValue && rangeValue.begin && rangeValue.end
                    ? this._dateAdapter.format(rangeValue.begin, this._dateFormats.display.dateInput) +
                        ' - ' +
                        this._dateAdapter.format(rangeValue.end, this._dateFormats.display.dateInput)
                    : '';
            if (oldDate == null && rangeValue != null || oldDate != null && rangeValue == null ||
                !this._dateAdapter.sameDate((/** @type {?} */ (oldDate)).begin, rangeValue.begin) ||
                !this._dateAdapter.sameDate((/** @type {?} */ (oldDate)).end, rangeValue.end)) {
                if (rangeValue.end && rangeValue.begin &&
                    this._dateAdapter
                        .compareDate(rangeValue.begin, rangeValue.end) > 0) {
                    // if begin > end
                    value = null;
                }
                this._value = value;
                this._valueChange.emit(value);
            }
        }
        else {
            /** Not range mode */
            value = this._dateAdapter.deserialize(value);
            this._lastValueValid = !value || this._dateAdapter.isValid(value);
            value = this._getValidDateOrNull(value);
            let /** @type {?} */ oldDate = this.value;
            this._value = value;
            this._elementRef.nativeElement.value =
                value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
            if (!this._dateAdapter.sameDate(/** @type {?} */ (oldDate), value)) {
                this._valueChange.emit(value);
            }
        }
    }
    /**
     * The minimum valid date.
     * @return {?}
     */
    get min() { return this._min; }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
        this._validatorOnChange();
    }
    /**
     * The maximum valid date.
     * @return {?}
     */
    get max() { return this._max; }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
        this._validatorOnChange();
    }
    /**
     * Whether the datepicker-input is disabled.
     * @return {?}
     */
    get disabled() { return !!this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        const /** @type {?} */ newValue = coerceBooleanProperty(value);
        const /** @type {?} */ element = this._elementRef.nativeElement;
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._disabledChange.emit(newValue);
        }
        // We need to null check the `blur` method, because it's undefined during SSR.
        if (newValue && element.blur) {
            // Normally, native input elements automatically blur if they turn disabled. This behavior
            // is problematic, because it would mean that it triggers another change detection cycle,
            // which then causes a changed after checked error if the input element was focused before.
            element.blur();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this._datepicker) {
            this._datepickerSubscription =
                this._datepicker._selectedChanged.subscribe((selected) => {
                    this.value = selected;
                    this._cvaOnChange(selected);
                    this._onTouched();
                    this.dateInput.emit(new matRangeDatepickerInputEvent(this, this._elementRef.nativeElement));
                    this.dateChange.emit(new matRangeDatepickerInputEvent(this, this._elementRef.nativeElement));
                });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._datepickerSubscription.unsubscribe();
        this._localeSubscription.unsubscribe();
        this._valueChange.complete();
        this._disabledChange.complete();
    }
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this._validatorOnChange = fn;
    }
    /**
     * \@docs-private
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this._validator ? this._validator(c) : null;
    }
    /**
     * @deprecated
     * \@deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead
     * @return {?}
     */
    getPopupConnectionElementRef() {
        return this.getConnectedOverlayOrigin();
    }
    /**
     * Gets the element that the datepicker popup should be connected to.
     * @return {?} The element to connect the popup to.
     */
    getConnectedOverlayOrigin() {
        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._cvaOnChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onKeydown(event) {
        if (event.altKey && event.keyCode === DOWN_ARROW) {
            this._datepicker.open();
            event.preventDefault();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    _onInput(value) {
        let /** @type {?} */ date = null;
        if (this._datepicker.rangeMode) {
            const /** @type {?} */ parts = value.split('-');
            if (parts.length > 1) {
                const /** @type {?} */ position = Math.floor(parts.length / 2);
                const /** @type {?} */ beginDateString = parts.slice(0, position).join('-');
                const /** @type {?} */ endDateString = parts.slice(position).join('-');
                let /** @type {?} */ beginDate = this._dateAdapter.parse(beginDateString, this._dateFormats.parse.dateInput);
                let /** @type {?} */ endDate = this._dateAdapter.parse(endDateString, this._dateFormats.parse.dateInput);
                this._lastValueValid = !beginDate || !endDate || this._dateAdapter.isValid(beginDate) &&
                    this._dateAdapter.isValid(endDate);
                beginDate = this._getValidDateOrNull(beginDate);
                endDate = this._getValidDateOrNull(endDate);
                if (beginDate && endDate) {
                    date = /** @type {?} */ ({ begin: beginDate, end: endDate });
                }
            }
        }
        else {
            date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);
            this._lastValueValid = !date || this._dateAdapter.isValid(date);
            date = this._getValidDateOrNull(date);
        }
        this._value = date;
        this._cvaOnChange(date);
        this._valueChange.emit(date);
        this.dateInput.emit(new matRangeDatepickerInputEvent(this, this._elementRef.nativeElement));
    }
    /**
     * @return {?}
     */
    _onChange() {
        this.dateChange.emit(new matRangeDatepickerInputEvent(this, this._elementRef.nativeElement));
    }
    /**
     * Returns the palette used by the input's form field, if any.
     * @return {?}
     */
    _getThemePalette() {
        return this._formField ? this._formField.color : undefined;
    }
    /**
     * Handles blur events on the input.
     * @return {?}
     */
    _onBlur() {
        // Reformat the input only if we have a valid value.
        if (this.value) {
            this._formatValue(this.value);
        }
        this._onTouched();
    }
    /**
     * Formats a value and sets it on the input element.
     * @param {?} value
     * @return {?}
     */
    _formatValue(value) {
        if (value && value.hasOwnProperty('begin') && value.hasOwnProperty('end')) {
            value = /** @type {?} */ (value);
            this._elementRef.nativeElement.value =
                value && value.begin && value.end
                    ? this._dateAdapter.format(value.begin, this._dateFormats.display.dateInput) +
                        ' - ' +
                        this._dateAdapter.format(value.end, this._dateFormats.display.dateInput)
                    : '';
        }
        else {
            value = /** @type {?} */ (value);
            this._elementRef.nativeElement.value =
                value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
        }
    }
    /**
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    _getValidDateOrNull(obj) {
        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
    }
}
matRangeDatepickerInput.decorators = [
    { type: Directive, args: [{
                selector: 'input[matRangeDatepicker]',
                providers: [
                    MAT_DATEPICKER_VALUE_ACCESSOR,
                    MAT_DATEPICKER_VALIDATORS,
                    { provide: MAT_INPUT_VALUE_ACCESSOR, useExisting: matRangeDatepickerInput },
                ],
                host: {
                    '[attr.aria-haspopup]': 'true',
                    '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',
                    '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',
                    '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',
                    '[disabled]': 'disabled',
                    '(input)': '_onInput($event.target.value)',
                    '(change)': '_onChange()',
                    '(blur)': '_onBlur()',
                    '(keydown)': '_onKeydown($event)',
                },
                exportAs: 'matDatepickerInput',
            },] },
];
/** @nocollapse */
matRangeDatepickerInput.ctorParameters = () => [
    { type: ElementRef, },
    { type: DateAdapter, decorators: [{ type: Optional },] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_FORMATS,] },] },
    { type: MatFormField, decorators: [{ type: Optional },] },
];
matRangeDatepickerInput.propDecorators = {
    "matRangeDatepicker": [{ type: Input },],
    "matDatepickerFilter": [{ type: Input },],
    "value": [{ type: Input },],
    "min": [{ type: Input },],
    "max": [{ type: Input },],
    "disabled": [{ type: Input },],
    "dateChange": [{ type: Output },],
    "dateInput": [{ type: Output },],
};
function matRangeDatepickerInput_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    matRangeDatepickerInput.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    matRangeDatepickerInput.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    matRangeDatepickerInput.propDecorators;
    /** @type {?} */
    matRangeDatepickerInput.prototype._datepicker;
    /** @type {?} */
    matRangeDatepickerInput.prototype._dateFilter;
    /** @type {?} */
    matRangeDatepickerInput.prototype._value;
    /** @type {?} */
    matRangeDatepickerInput.prototype._min;
    /** @type {?} */
    matRangeDatepickerInput.prototype._max;
    /** @type {?} */
    matRangeDatepickerInput.prototype._disabled;
    /**
     * Emits when a `change` event is fired on this `<input>`.
     * @type {?}
     */
    matRangeDatepickerInput.prototype.dateChange;
    /**
     * Emits when an `input` event is fired on this `<input>`.
     * @type {?}
     */
    matRangeDatepickerInput.prototype.dateInput;
    /**
     * Emits when the value changes (either due to user input or programmatic change).
     * @type {?}
     */
    matRangeDatepickerInput.prototype._valueChange;
    /**
     * Emits when the disabled state has changed
     * @type {?}
     */
    matRangeDatepickerInput.prototype._disabledChange;
    /** @type {?} */
    matRangeDatepickerInput.prototype._onTouched;
    /** @type {?} */
    matRangeDatepickerInput.prototype._cvaOnChange;
    /** @type {?} */
    matRangeDatepickerInput.prototype._validatorOnChange;
    /** @type {?} */
    matRangeDatepickerInput.prototype._datepickerSubscription;
    /** @type {?} */
    matRangeDatepickerInput.prototype._localeSubscription;
    /**
     * The form control validator for whether the input parses.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._parseValidator;
    /**
     * The form control validator for the min date.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._minValidator;
    /**
     * The form control validator for the max date.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._maxValidator;
    /**
     * The form control validator for the date filter.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._filterValidator;
    /**
     * The form control validator for the date filter.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._rangeValidator;
    /**
     * The combined form control validator for this input.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._validator;
    /**
     * Whether the last value set on the input was valid.
     * @type {?}
     */
    matRangeDatepickerInput.prototype._lastValueValid;
    /** @type {?} */
    matRangeDatepickerInput.prototype._elementRef;
    /** @type {?} */
    matRangeDatepickerInput.prototype._dateAdapter;
    /** @type {?} */
    matRangeDatepickerInput.prototype._dateFormats;
    /** @type {?} */
    matRangeDatepickerInput.prototype._formField;
}
//# sourceMappingURL=datepicker-input.js.map
