/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directionality } from '@angular/cdk/bidi';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE, UP_ARROW } from '@angular/cdk/keycodes';
import { Overlay, OverlayConfig, } from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import { DOCUMENT } from '@angular/common';
import { filter, take } from 'rxjs/operators';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Inject, inject, InjectionToken, Input, NgZone, Optional, Output, ViewChild, ViewContainerRef, ViewEncapsulation, } from '@angular/core';
import { mixinColor } from '@angular/material/core';
import { MatDialog } from '@angular/material/dialog';
import { merge, Subject, Subscription } from 'rxjs';
import { RangeCalendar } from './range-calendar';
import { matDatepickerAnimations } from './datepicker-animations';
import { createMissingDateImplError } from './datepicker-errors';
import { DateAdapter } from '../datetime/date-adapter';
/**
 * Used to generate a unique ID for each datepicker instance.
 */
let /** @type {?} */ datepickerUid = 0;
/**
 * Injection token that determines the scroll handling while the calendar is open.
 */
export const /** @type {?} */ MAT_DATEPICKER_SCROLL_STRATEGY = new InjectionToken('mat-range-datepicker-scroll-strategy', {
    providedIn: 'root',
    factory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY,
});
/**
 * \@docs-private
 * @return {?}
 */
export function MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY() {
    const /** @type {?} */ overlay = inject(Overlay);
    return () => overlay.scrollStrategies.reposition();
}
/**
 * \@docs-private
 */
export class matRangeDatepickerContentBase {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}
function matRangeDatepickerContentBase_tsickle_Closure_declarations() {
    /** @type {?} */
    matRangeDatepickerContentBase.prototype._elementRef;
}
export const /** @type {?} */ _matRangeDatepickerContentMixinBase = mixinColor(matRangeDatepickerContentBase);
/**
 * Component used as the content for the datepicker dialog and popup. We use this instead of using
 * SatCalendar directly as the content so we can control the initial focus. This also gives us a
 * place to put additional features of the popup that are not part of the calendar itself in the
 * future. (e.g. confirmation buttons).
 * \@docs-private
 * @template D
 */
export class matRangeDatepickerContent extends _matRangeDatepickerContentMixinBase {
    /**
     * @param {?} elementRef
     * @param {?} _changeDetectorRef
     * @param {?} _ngZone
     */
    constructor(elementRef, _changeDetectorRef, _ngZone) {
        super(elementRef);
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.datepicker._popupRef || this._positionChange) {
            return;
        }
        const /** @type {?} */ positionStrategy = /** @type {?} */ (((this.datepicker._popupRef.getConfig().positionStrategy)));
        this._positionChange = positionStrategy.positionChanges.subscribe(change => {
            const /** @type {?} */ isAbove = change.connectionPair.overlayY === 'bottom';
            if (isAbove !== this._isAbove) {
                this._ngZone.run(() => {
                    this._isAbove = isAbove;
                    this._changeDetectorRef.markForCheck();
                });
            }
        });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // this._calendar.focusActiveCell();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._positionChange) {
            this._positionChange.unsubscribe();
            this._positionChange = null;
        }
    }
}
matRangeDatepickerContent.decorators = [
    { type: Component, args: [{
                moduleId: module.id,
                selector: 'mat-range-datepicker-content',
                template: `<range-calendar cdkTrapFocus
              [id]="datepicker.id"
              [ngClass]="datepicker.panelClass"
              [startAt]="datepicker.startAt"
              [startView]="datepicker.startView"
              [minDate]="datepicker._minDate"
              [maxDate]="datepicker._maxDate"
              [dateFilter]="datepicker._dateFilter"
              [beginDate]="datepicker._beginDate"
              [endDate]="datepicker._endDate"
              [rangeMode]="datepicker.rangeMode"
              [selected]="datepicker._selected"
              (selectedChange)="datepicker._select($event)"
              (dateRangesChange)="datepicker._selectRange($event)"
              (yearSelected)="datepicker._selectYear($event)"
              (monthSelected)="datepicker._selectMonth($event)"
              (_userSelection)="datepicker.close($event)">
</range-calendar>
`,
                styles: [`.mat-datepicker-content{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);display:block;width:593px;height:493px}.end-date-sec,.from-date-sec{display:inline-block;width:50%;height:360px;box-sizing:border-box}.from-date-sec{border-right:.5px solid #e9e9e9}.end-date-sec{border-left:0 solid #e9e9e9}.quick-select-sec{border-top:1px solid #e9e9e9;border-bottom:1px solid #e9e9e9;height:50px;line-height:50px;padding:0 20px;font-size:14px;font-weight:200}.quick-select-sec .select-title{color:#9f9f9f}.quick-select-sec ul{display:inline-block;list-style-type:none;margin:0;color:#696969}.quick-select-sec ul li{display:inline-block;margin-left:10px}.quick-select-sec ul li .mat-button{font-size:13px;font-weight:400}.calendar-button-sec{padding:0 20px;text-align:right;line-height:80px}.calendar-button-sec button{margin-left:10px}.mat-datepicker-content-touch{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-semi-selected),.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-semi-selected),:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-semi-selected){background-color:rgba(0,0,0,.04)}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-semi-selected,.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-semi-selected,:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-semi-selected{background-color:#3f51b5;color:#fff}.mat-calendar-body-begin-range:not(.mat-calendar-body-end-range){border-radius:100% 0 0 100%;background-color:#e8eaf6}.mat-calendar-body-end-range:not(.mat-calendar-body-begin-range){border-radius:0 100% 100% 0;background-color:#e8eaf6}.mat-calendar-body>tr .mat-calendar-cell-semi-selected~.mat-calendar-cell-semi-selected{border-radius:0}.mat-calendar-cell-semi-selected{background-color:#f0e7ff}.mat-button.active .mat-button-focus-overlay{opacity:1}`],
                host: {
                    'class': 'mat-datepicker-content',
                    '[@transformPanel]': '"enter"',
                    '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',
                    '[class.mat-datepicker-content-above]': '_isAbove',
                },
                animations: [
                    matDatepickerAnimations.transformPanel,
                    matDatepickerAnimations.fadeInCalendar,
                ],
                exportAs: 'matDatepickerContent',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                inputs: ['color'],
            },] },
];
/** @nocollapse */
matRangeDatepickerContent.ctorParameters = () => [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
    { type: NgZone, },
];
matRangeDatepickerContent.propDecorators = {
    "_calendar": [{ type: ViewChild, args: [RangeCalendar,] },],
};
function matRangeDatepickerContent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    matRangeDatepickerContent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    matRangeDatepickerContent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    matRangeDatepickerContent.propDecorators;
    /**
     * Subscription to changes in the overlay's position.
     * @type {?}
     */
    matRangeDatepickerContent.prototype._positionChange;
    /**
     * Reference to the internal calendar component.
     * @type {?}
     */
    matRangeDatepickerContent.prototype._calendar;
    /**
     * Reference to the datepicker that created the overlay.
     * @type {?}
     */
    matRangeDatepickerContent.prototype.datepicker;
    /**
     * Whether the datepicker is above or below the input.
     * @type {?}
     */
    matRangeDatepickerContent.prototype._isAbove;
    /** @type {?} */
    matRangeDatepickerContent.prototype._changeDetectorRef;
    /** @type {?} */
    matRangeDatepickerContent.prototype._ngZone;
}
/**
 * Component responsible for managing the datepicker popup/dialog.
 * @template D
 */
export class matRangeDatepicker {
    /**
     * @param {?} _dialog
     * @param {?} _overlay
     * @param {?} _ngZone
     * @param {?} _viewContainerRef
     * @param {?} _scrollStrategy
     * @param {?} _dateAdapter
     * @param {?} _dir
     * @param {?} _document
     */
    constructor(_dialog, _overlay, _ngZone, _viewContainerRef, _scrollStrategy, _dateAdapter, _dir, _document) {
        this._dialog = _dialog;
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._viewContainerRef = _viewContainerRef;
        this._scrollStrategy = _scrollStrategy;
        this._dateAdapter = _dateAdapter;
        this._dir = _dir;
        this._document = _document;
        /**
         * The view that the calendar should start in.
         */
        this.startView = 'month';
        this._touchUi = false;
        /**
         * Emits selected year in multiyear view.
         * This doesn't imply a change on the selected date.
         */
        this.yearSelected = new EventEmitter();
        /**
         * Emits selected month in year view.
         * This doesn't imply a change on the selected date.
         */
        this.monthSelected = new EventEmitter();
        /**
         * Emits when the datepicker has been opened.
         */
        this.openedStream = new EventEmitter();
        /**
         * Emits when the datepicker has been closed.
         */
        this.closedStream = new EventEmitter();
        this._opened = false;
        /**
         * The id for the datepicker calendar.
         */
        this.id = `mat-range-datepicker-${datepickerUid++}`;
        this._validSelected = null;
        /**
         * The element that was focused before the datepicker was opened.
         */
        this._focusedElementBeforeOpen = null;
        /**
         * Subscription to value changes in the associated input element.
         */
        this._inputSubscription = Subscription.EMPTY;
        /**
         * Emits when the datepicker is disabled.
         */
        this._disabledChange = new Subject();
        /**
         * Emits new selected date when selected date changes.
         */
        this._selectedChanged = new Subject();
        if (!this._dateAdapter) {
            throw createMissingDateImplError('DateAdapter');
        }
    }
    /**
     * Whenever datepicker is for selecting range of dates.
     * @return {?}
     */
    get rangeMode() {
        return this._rangeMode;
    }
    /**
     * @param {?} mode
     * @return {?}
     */
    set rangeMode(mode) {
        this._rangeMode = mode;
        if (this.rangeMode) {
            this._validSelected = null;
        }
        else {
            this._beginDate = this._endDate = null;
        }
    }
    /**
     * Start of dates interval.
     * @return {?}
     */
    get beginDate() { return this._beginDate; }
    /**
     * @param {?} value
     * @return {?}
     */
    set beginDate(value) {
        this._validSelected = null;
        this._beginDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
    }
    /**
     * End of dates interval.
     * @return {?}
     */
    get endDate() { return this._endDate; }
    /**
     * @param {?} value
     * @return {?}
     */
    set endDate(value) {
        this._validSelected = null;
        this._endDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
    }
    /**
     * The date to open the calendar to initially.
     * @return {?}
     */
    get startAt() {
        // If an explicit startAt is set we start there, otherwise we start at whatever the currently
        // selected value is.
        if (this.rangeMode) {
            return this._startAt || (this._datepickerInput && this._datepickerInput.value ?
                (/** @type {?} */ (this._datepickerInput.value)).begin : null);
        }
        return this._startAt || (this._datepickerInput ? /** @type {?} */ (this._datepickerInput.value) : null);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set startAt(value) {
        this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
    }
    /**
     * Color palette to use on the datepicker's calendar.
     * @return {?}
     */
    get color() {
        return this._color ||
            (this._datepickerInput ? this._datepickerInput._getThemePalette() : undefined);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set color(value) {
        this._color = value;
    }
    /**
     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
     * than a popup and elements have more padding to allow for bigger touch targets.
     * @return {?}
     */
    get touchUi() { return this._touchUi; }
    /**
     * @param {?} value
     * @return {?}
     */
    set touchUi(value) {
        this._touchUi = coerceBooleanProperty(value);
    }
    /**
     * Whether the datepicker pop-up should be disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled === undefined && this._datepickerInput ?
            this._datepickerInput.disabled : !!this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        const /** @type {?} */ newValue = coerceBooleanProperty(value);
        if (newValue !== this._disabled) {
            this._disabled = newValue;
            this._disabledChange.next(newValue);
        }
    }
    /**
     * Whether the calendar is open.
     * @return {?}
     */
    get opened() { return this._opened; }
    /**
     * @param {?} value
     * @return {?}
     */
    set opened(value) { value ? this.open() : this.close(); }
    /**
     * The currently selected date.
     * @return {?}
     */
    get _selected() { return this._validSelected; }
    /**
     * @param {?} value
     * @return {?}
     */
    set _selected(value) { this._validSelected = value; }
    /**
     * The minimum selectable date.
     * @return {?}
     */
    get _minDate() {
        return this._datepickerInput && this._datepickerInput.min;
    }
    /**
     * The maximum selectable date.
     * @return {?}
     */
    get _maxDate() {
        return this._datepickerInput && this._datepickerInput.max;
    }
    /**
     * @return {?}
     */
    get _dateFilter() {
        return this._datepickerInput && this._datepickerInput._dateFilter;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._initBeginDate = this.beginDate;
        this._initEndDate = this.endDate;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.close();
        this._inputSubscription.unsubscribe();
        this._disabledChange.complete();
        if (this._popupRef) {
            this._popupRef.dispose();
            this._popupComponentRef = null;
        }
    }
    /**
     * Selects the given date
     * @param {?} date
     * @return {?}
     */
    _select(date) {
        let /** @type {?} */ oldValue = this._selected;
        this._selected = date;
        if (!this._dateAdapter.sameDate(oldValue, this._selected)) {
            this._selectedChanged.next(date);
        }
    }
    /**
     * Selects the given date range
     * @param {?} dates
     * @return {?}
     */
    _selectRange(dates) {
        if (!this._dateAdapter.sameDate(dates.begin, this.beginDate) ||
            !this._dateAdapter.sameDate(dates.end, this.endDate)) {
            this._selectedChanged.next(dates);
        }
        this._beginDate = dates.begin;
        this._endDate = dates.end;
    }
    /**
     * Emits the selected year in multiyear view
     * @param {?} normalizedYear
     * @return {?}
     */
    _selectYear(normalizedYear) {
        this.yearSelected.emit(normalizedYear);
    }
    /**
     * Emits selected month in year view
     * @param {?} normalizedMonth
     * @return {?}
     */
    _selectMonth(normalizedMonth) {
        this.monthSelected.emit(normalizedMonth);
    }
    /**
     * Register an input with this datepicker.
     * @param {?} input The datepicker input to register with this datepicker.
     * @return {?}
     */
    _registerInput(input) {
        if (this._datepickerInput) {
            throw Error('A matRangeDatepicker can only be associated with a single input.');
        }
        this._datepickerInput = input;
        this._inputSubscription =
            this._datepickerInput._valueChange
                .subscribe((value) => {
                if (value === null) {
                    this.beginDate = this.endDate = this._selected = null;
                    return;
                }
                if (this.rangeMode) {
                    value = /** @type {?} */ (value);
                    if (value.begin && value.end &&
                        this._dateAdapter.compareDate(value.begin, value.end) <= 0) {
                        this.beginDate = value.begin;
                        this.endDate = value.end;
                    }
                    else {
                        this.beginDate = this.endDate = null;
                    }
                }
                else {
                    this._selected = /** @type {?} */ (value);
                }
            });
    }
    /**
     * Open the calendar.
     * @return {?}
     */
    open() {
        this._initBeginDate = this.beginDate;
        this._initEndDate = this.endDate;
        if (this._opened || this.disabled) {
            return;
        }
        if (!this._datepickerInput) {
            throw Error('Attempted to open an matRangeDatepicker with no associated input.');
        }
        if (this._document) {
            this._focusedElementBeforeOpen = this._document.activeElement;
        }
        this.touchUi ? this._openAsDialog() : this._openAsPopup();
        this._opened = true;
        this.openedStream.emit();
    }
    /**
     * Close the calendar.
     * @param {?=} options
     * @return {?}
     */
    close(options) {
        if (!this._opened) {
            return;
        }
        if (this._popupRef && this._popupRef.hasAttached()) {
            this._popupRef.detach();
        }
        if (this._dialogRef) {
            this._dialogRef.close();
            this._dialogRef = null;
        }
        if (this._calendarPortal && this._calendarPortal.isAttached) {
            this._calendarPortal.detach();
        }
        //restore if not applied
        if (!options || !options.apply) {
            this.beginDate = this._initBeginDate;
            this.endDate = this._initEndDate;
            this._selectedChanged.next({
                begin: this.beginDate,
                end: this.endDate,
            });
        }
        const /** @type {?} */ completeClose = () => {
            // The `_opened` could've been reset already if
            // we got two events in quick succession.
            if (this._opened) {
                this._opened = false;
                this.closedStream.emit();
                this._focusedElementBeforeOpen = null;
            }
        };
        if (this._focusedElementBeforeOpen &&
            typeof this._focusedElementBeforeOpen.focus === 'function') {
            // Because IE moves focus asynchronously, we can't count on it being restored before we've
            // marked the datepicker as closed. If the event fires out of sequence and the element that
            // we're refocusing opens the datepicker on focus, the user could be stuck with not being
            // able to close the calendar at all. We work around it by making the logic, that marks
            // the datepicker as closed, async as well.
            this._focusedElementBeforeOpen.focus();
            setTimeout(completeClose);
        }
        else {
            completeClose();
        }
    }
    /**
     * Open the calendar as a dialog.
     * @return {?}
     */
    _openAsDialog() {
        this._dialogRef = this._dialog.open(matRangeDatepickerContent, {
            direction: this._getDirection(),
            viewContainerRef: this._viewContainerRef,
            panelClass: 'mat-datepicker-dialog',
        });
        this._dialogRef.afterClosed().subscribe(() => this.close());
        this._dialogRef.componentInstance.datepicker = this;
        this._setColor();
    }
    /**
     * Open the calendar as a popup.
     * @return {?}
     */
    _openAsPopup() {
        if (!this._calendarPortal) {
            this._calendarPortal = new ComponentPortal(matRangeDatepickerContent, this._viewContainerRef);
        }
        if (!this._popupRef) {
            this._createPopup();
        }
        if (!this._popupRef.hasAttached()) {
            this._popupRef.setDirection(this._getDirection());
            this._popupComponentRef = this._popupRef.attach(this._calendarPortal);
            this._popupComponentRef.instance.datepicker = this;
            this._setColor();
            // Update the position once the calendar has rendered.
            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this._popupRef.updatePosition();
            });
        }
    }
    /**
     * Create the popup.
     * @return {?}
     */
    _createPopup() {
        const /** @type {?} */ overlayConfig = new OverlayConfig({
            positionStrategy: this._createPopupPositionStrategy(),
            hasBackdrop: true,
            backdropClass: 'mat-overlay-transparent-backdrop',
            direction: this._getDirection(),
            scrollStrategy: this._scrollStrategy(),
            panelClass: 'mat-datepicker-popup',
        });
        this._popupRef = this._overlay.create(overlayConfig);
        merge(this._popupRef.backdropClick(), 
        // this._popupRef.detachments(),
        this._popupRef.keydownEvents().pipe(filter(event => {
            // Closing on alt + up is only valid when there's an input associated with the datepicker.
            return event.keyCode === ESCAPE ||
                (this._datepickerInput && event.altKey && event.keyCode === UP_ARROW);
        }))).subscribe(() => this.close());
    }
    /**
     * Create the popup PositionStrategy.
     * @return {?}
     */
    _createPopupPositionStrategy() {
        return this._overlay.position()
            .flexibleConnectedTo(this._datepickerInput.getPopupConnectionElementRef())
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withPush(false)
            .withPositions([
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top'
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom'
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'top'
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'bottom'
            }
        ]);
    }
    /**
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    _getValidDateOrNull(obj) {
        return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
    }
    /**
     * Passes the current theme color along to the calendar overlay.
     * @return {?}
     */
    _setColor() {
        const /** @type {?} */ color = this.color;
        if (this._popupComponentRef) {
            this._popupComponentRef.instance.color = color;
        }
        if (this._dialogRef) {
            this._dialogRef.componentInstance.color = color;
        }
    }
    /**
     * Returns the layout direction of the datepicker.
     * @return {?}
     */
    _getDirection() {
        return this._dir ? this._dir.value : 'ltr';
    }
}
matRangeDatepicker.decorators = [
    { type: Component, args: [{
                moduleId: module.id,
                selector: 'mat-range-datepicker',
                template: '',
                exportAs: 'matDatepicker',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
matRangeDatepicker.ctorParameters = () => [
    { type: MatDialog, },
    { type: Overlay, },
    { type: NgZone, },
    { type: ViewContainerRef, },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DATEPICKER_SCROLL_STRATEGY,] },] },
    { type: DateAdapter, decorators: [{ type: Optional },] },
    { type: Directionality, decorators: [{ type: Optional },] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] },] },
];
matRangeDatepicker.propDecorators = {
    "rangeMode": [{ type: Input },],
    "beginDate": [{ type: Input },],
    "endDate": [{ type: Input },],
    "calendarHeaderComponent": [{ type: Input },],
    "startAt": [{ type: Input },],
    "startView": [{ type: Input },],
    "color": [{ type: Input },],
    "touchUi": [{ type: Input },],
    "disabled": [{ type: Input },],
    "yearSelected": [{ type: Output },],
    "monthSelected": [{ type: Output },],
    "panelClass": [{ type: Input },],
    "openedStream": [{ type: Output, args: ['opened',] },],
    "closedStream": [{ type: Output, args: ['closed',] },],
    "opened": [{ type: Input },],
};
function matRangeDatepicker_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    matRangeDatepicker.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    matRangeDatepicker.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    matRangeDatepicker.propDecorators;
    /** @type {?} */
    matRangeDatepicker.prototype._rangeMode;
    /** @type {?} */
    matRangeDatepicker.prototype._beginDate;
    /** @type {?} */
    matRangeDatepicker.prototype._initBeginDate;
    /** @type {?} */
    matRangeDatepicker.prototype._endDate;
    /** @type {?} */
    matRangeDatepicker.prototype._initEndDate;
    /**
     * An input indicating the type of the custom header component for the calendar, if set.
     * @type {?}
     */
    matRangeDatepicker.prototype.calendarHeaderComponent;
    /** @type {?} */
    matRangeDatepicker.prototype._startAt;
    /**
     * The view that the calendar should start in.
     * @type {?}
     */
    matRangeDatepicker.prototype.startView;
    /** @type {?} */
    matRangeDatepicker.prototype._color;
    /** @type {?} */
    matRangeDatepicker.prototype._touchUi;
    /** @type {?} */
    matRangeDatepicker.prototype._disabled;
    /**
     * Emits selected year in multiyear view.
     * This doesn't imply a change on the selected date.
     * @type {?}
     */
    matRangeDatepicker.prototype.yearSelected;
    /**
     * Emits selected month in year view.
     * This doesn't imply a change on the selected date.
     * @type {?}
     */
    matRangeDatepicker.prototype.monthSelected;
    /**
     * Classes to be passed to the date picker panel. Supports the same syntax as `ngClass`.
     * @type {?}
     */
    matRangeDatepicker.prototype.panelClass;
    /**
     * Emits when the datepicker has been opened.
     * @type {?}
     */
    matRangeDatepicker.prototype.openedStream;
    /**
     * Emits when the datepicker has been closed.
     * @type {?}
     */
    matRangeDatepicker.prototype.closedStream;
    /** @type {?} */
    matRangeDatepicker.prototype._opened;
    /**
     * The id for the datepicker calendar.
     * @type {?}
     */
    matRangeDatepicker.prototype.id;
    /** @type {?} */
    matRangeDatepicker.prototype._validSelected;
    /**
     * A reference to the overlay when the calendar is opened as a popup.
     * @type {?}
     */
    matRangeDatepicker.prototype._popupRef;
    /**
     * A reference to the dialog when the calendar is opened as a dialog.
     * @type {?}
     */
    matRangeDatepicker.prototype._dialogRef;
    /**
     * A portal containing the calendar for this datepicker.
     * @type {?}
     */
    matRangeDatepicker.prototype._calendarPortal;
    /**
     * Reference to the component instantiated in popup mode.
     * @type {?}
     */
    matRangeDatepicker.prototype._popupComponentRef;
    /**
     * The element that was focused before the datepicker was opened.
     * @type {?}
     */
    matRangeDatepicker.prototype._focusedElementBeforeOpen;
    /**
     * Subscription to value changes in the associated input element.
     * @type {?}
     */
    matRangeDatepicker.prototype._inputSubscription;
    /**
     * The input element this datepicker is associated with.
     * @type {?}
     */
    matRangeDatepicker.prototype._datepickerInput;
    /**
     * Emits when the datepicker is disabled.
     * @type {?}
     */
    matRangeDatepicker.prototype._disabledChange;
    /**
     * Emits new selected date when selected date changes.
     * @type {?}
     */
    matRangeDatepicker.prototype._selectedChanged;
    /** @type {?} */
    matRangeDatepicker.prototype._dialog;
    /** @type {?} */
    matRangeDatepicker.prototype._overlay;
    /** @type {?} */
    matRangeDatepicker.prototype._ngZone;
    /** @type {?} */
    matRangeDatepicker.prototype._viewContainerRef;
    /** @type {?} */
    matRangeDatepicker.prototype._scrollStrategy;
    /** @type {?} */
    matRangeDatepicker.prototype._dateAdapter;
    /** @type {?} */
    matRangeDatepicker.prototype._dir;
    /** @type {?} */
    matRangeDatepicker.prototype._document;
}
//# sourceMappingURL=datepicker.js.map
