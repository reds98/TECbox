/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Direction, Directionality } from '@angular/cdk/bidi';
import { BooleanInput } from '@angular/cdk/coercion';
import { ElementRef, EventEmitter, InjectionToken, OnChanges, OnDestroy, SimpleChanges, TemplateRef, ViewContainerRef } from '@angular/core';
import { Overlay } from './overlay';
import { OverlayRef } from './overlay-ref';
import { ConnectedOverlayPositionChange } from './position/connected-position';
import { ConnectedPosition, FlexibleConnectedPositionStrategy } from './position/flexible-connected-position-strategy';
import { RepositionScrollStrategy, ScrollStrategy } from './scroll/index';
/** Injection token that determines the scroll handling while the connected overlay is open. */
import * as ɵngcc0 from '@angular/core';
export declare const CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;
/** @docs-private @deprecated @breaking-change 8.0.0 */
export declare function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;
/**
 * Directive applied to an element to make it usable as an origin for an Overlay using a
 * ConnectedPositionStrategy.
 */
export declare class CdkOverlayOrigin {
    /** Reference to the element on which the directive is applied. */
    elementRef: ElementRef;
    constructor(
    /** Reference to the element on which the directive is applied. */
    elementRef: ElementRef);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CdkOverlayOrigin, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<CdkOverlayOrigin, "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]", ["cdkOverlayOrigin"], {}, {}, never>;
}
/**
 * Directive to facilitate declarative creation of an
 * Overlay using a FlexibleConnectedPositionStrategy.
 */
export declare class CdkConnectedOverlay implements OnDestroy, OnChanges {
    private _overlay;
    private _dir;
    private _overlayRef;
    private _templatePortal;
    private _hasBackdrop;
    private _lockPosition;
    private _growAfterOpen;
    private _flexibleDimensions;
    private _push;
    private _backdropSubscription;
    private _offsetX;
    private _offsetY;
    private _position;
    private _scrollStrategyFactory;
    /** Origin for the connected overlay. */
    origin: CdkOverlayOrigin;
    /** Registered connected position pairs. */
    positions: ConnectedPosition[];
    /**
     * This input overrides the positions input if specified. It lets users pass
     * in arbitrary positioning strategies.
     */
    positionStrategy: FlexibleConnectedPositionStrategy;
    /** The offset in pixels for the overlay connection point on the x-axis */
    get offsetX(): number;
    set offsetX(offsetX: number);
    /** The offset in pixels for the overlay connection point on the y-axis */
    get offsetY(): number;
    set offsetY(offsetY: number);
    /** The width of the overlay panel. */
    width: number | string;
    /** The height of the overlay panel. */
    height: number | string;
    /** The min width of the overlay panel. */
    minWidth: number | string;
    /** The min height of the overlay panel. */
    minHeight: number | string;
    /** The custom class to be set on the backdrop element. */
    backdropClass: string;
    /** The custom class to add to the overlay pane element. */
    panelClass: string | string[];
    /** Margin between the overlay and the viewport edges. */
    viewportMargin: number;
    /** Strategy to be used when handling scroll events while the overlay is open. */
    scrollStrategy: ScrollStrategy;
    /** Whether the overlay is open. */
    open: boolean;
    /** CSS selector which to set the transform origin. */
    transformOriginSelector: string;
    /** Whether or not the overlay should attach a backdrop. */
    get hasBackdrop(): any;
    set hasBackdrop(value: any);
    /** Whether or not the overlay should be locked when scrolling. */
    get lockPosition(): any;
    set lockPosition(value: any);
    /** Whether the overlay's width and height can be constrained to fit within the viewport. */
    get flexibleDimensions(): boolean;
    set flexibleDimensions(value: boolean);
    /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */
    get growAfterOpen(): boolean;
    set growAfterOpen(value: boolean);
    /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */
    get push(): boolean;
    set push(value: boolean);
    /** Event emitted when the backdrop is clicked. */
    backdropClick: EventEmitter<MouseEvent>;
    /** Event emitted when the position has changed. */
    positionChange: EventEmitter<ConnectedOverlayPositionChange>;
    /** Event emitted when the overlay has been attached. */
    attach: EventEmitter<void>;
    /** Event emitted when the overlay has been detached. */
    detach: EventEmitter<void>;
    /** Emits when there are keyboard events that are targeted at the overlay. */
    overlayKeydown: EventEmitter<KeyboardEvent>;
    constructor(_overlay: Overlay, templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef, scrollStrategyFactory: any, _dir: Directionality);
    /** The associated overlay reference. */
    get overlayRef(): OverlayRef;
    /** The element's layout direction. */
    get dir(): Direction;
    ngOnDestroy(): void;
    ngOnChanges(changes: SimpleChanges): void;
    /** Creates an overlay */
    private _createOverlay;
    /** Builds the overlay config based on the directive's inputs */
    private _buildConfig;
    /** Updates the state of a position strategy, based on the values of the directive inputs. */
    private _updatePositionStrategy;
    /** Returns the position strategy of the overlay to be set on the overlay config */
    private _createPositionStrategy;
    /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */
    private _attachOverlay;
    /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */
    private _detachOverlay;
    static ngAcceptInputType_hasBackdrop: BooleanInput;
    static ngAcceptInputType_lockPosition: BooleanInput;
    static ngAcceptInputType_flexibleDimensions: BooleanInput;
    static ngAcceptInputType_growAfterOpen: BooleanInput;
    static ngAcceptInputType_push: BooleanInput;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CdkConnectedOverlay, [null, null, null, null, { optional: true; }]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<CdkConnectedOverlay, "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]", ["cdkConnectedOverlay"], { "viewportMargin": "cdkConnectedOverlayViewportMargin"; "open": "cdkConnectedOverlayOpen"; "scrollStrategy": "cdkConnectedOverlayScrollStrategy"; "offsetX": "cdkConnectedOverlayOffsetX"; "offsetY": "cdkConnectedOverlayOffsetY"; "hasBackdrop": "cdkConnectedOverlayHasBackdrop"; "lockPosition": "cdkConnectedOverlayLockPosition"; "flexibleDimensions": "cdkConnectedOverlayFlexibleDimensions"; "growAfterOpen": "cdkConnectedOverlayGrowAfterOpen"; "push": "cdkConnectedOverlayPush"; "positions": "cdkConnectedOverlayPositions"; "origin": "cdkConnectedOverlayOrigin"; "positionStrategy": "cdkConnectedOverlayPositionStrategy"; "width": "cdkConnectedOverlayWidth"; "height": "cdkConnectedOverlayHeight"; "minWidth": "cdkConnectedOverlayMinWidth"; "minHeight": "cdkConnectedOverlayMinHeight"; "backdropClass": "cdkConnectedOverlayBackdropClass"; "panelClass": "cdkConnectedOverlayPanelClass"; "transformOriginSelector": "cdkConnectedOverlayTransformOriginOn"; }, { "backdropClick": "backdropClick"; "positionChange": "positionChange"; "attach": "attach"; "detach": "detach"; "overlayKeydown": "overlayKeydown"; }, never>;
}
/** @docs-private */
export declare function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => RepositionScrollStrategy;
/** @docs-private */
export declare const CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER: {
    provide: InjectionToken<() => ScrollStrategy>;
    deps: (typeof Overlay)[];
    useFactory: typeof CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY;
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheS1kaXJlY3RpdmVzLmQudHMiLCJzb3VyY2VzIjpbIm92ZXJsYXktZGlyZWN0aXZlcy5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3R0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHsgRGlyZWN0aW9uLCBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcclxuaW1wb3J0IHsgQm9vbGVhbklucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcclxuaW1wb3J0IHsgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbmplY3Rpb25Ub2tlbiwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE92ZXJsYXkgfSBmcm9tICcuL292ZXJsYXknO1xyXG5pbXBvcnQgeyBPdmVybGF5UmVmIH0gZnJvbSAnLi9vdmVybGF5LXJlZic7XHJcbmltcG9ydCB7IENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZSB9IGZyb20gJy4vcG9zaXRpb24vY29ubmVjdGVkLXBvc2l0aW9uJztcclxuaW1wb3J0IHsgQ29ubmVjdGVkUG9zaXRpb24sIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB9IGZyb20gJy4vcG9zaXRpb24vZmxleGlibGUtY29ubmVjdGVkLXBvc2l0aW9uLXN0cmF0ZWd5JztcclxuaW1wb3J0IHsgUmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5LCBTY3JvbGxTdHJhdGVneSB9IGZyb20gJy4vc2Nyb2xsL2luZGV4JztcclxuLyoqIEluamVjdGlvbiB0b2tlbiB0aGF0IGRldGVybWluZXMgdGhlIHNjcm9sbCBoYW5kbGluZyB3aGlsZSB0aGUgY29ubmVjdGVkIG92ZXJsYXkgaXMgb3Blbi4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY29uc3QgQ0RLX0NPTk5FQ1RFRF9PVkVSTEFZX1NDUk9MTF9TVFJBVEVHWTogSW5qZWN0aW9uVG9rZW48KCkgPT4gU2Nyb2xsU3RyYXRlZ3k+O1xyXG4vKiogQGRvY3MtcHJpdmF0ZSBAZGVwcmVjYXRlZCBAYnJlYWtpbmctY2hhbmdlIDguMC4wICovXHJcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIENES19DT05ORUNURURfT1ZFUkxBWV9TQ1JPTExfU1RSQVRFR1lfRkFDVE9SWShvdmVybGF5OiBPdmVybGF5KTogKCkgPT4gU2Nyb2xsU3RyYXRlZ3k7XHJcbi8qKlxyXG4gKiBEaXJlY3RpdmUgYXBwbGllZCB0byBhbiBlbGVtZW50IHRvIG1ha2UgaXQgdXNhYmxlIGFzIGFuIG9yaWdpbiBmb3IgYW4gT3ZlcmxheSB1c2luZyBhXHJcbiAqIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kuXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDZGtPdmVybGF5T3JpZ2luIHtcclxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGRpcmVjdGl2ZSBpcyBhcHBsaWVkLiAqL1xyXG4gICAgZWxlbWVudFJlZjogRWxlbWVudFJlZjtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBvbiB3aGljaCB0aGUgZGlyZWN0aXZlIGlzIGFwcGxpZWQuICovXHJcbiAgICBlbGVtZW50UmVmOiBFbGVtZW50UmVmKTtcclxufVxyXG4vKipcclxuICogRGlyZWN0aXZlIHRvIGZhY2lsaXRhdGUgZGVjbGFyYXRpdmUgY3JlYXRpb24gb2YgYW5cclxuICogT3ZlcmxheSB1c2luZyBhIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5cclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENka0Nvbm5lY3RlZE92ZXJsYXkgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XHJcbiAgICBwcml2YXRlIF9vdmVybGF5O1xyXG4gICAgcHJpdmF0ZSBfZGlyO1xyXG4gICAgcHJpdmF0ZSBfb3ZlcmxheVJlZjtcclxuICAgIHByaXZhdGUgX3RlbXBsYXRlUG9ydGFsO1xyXG4gICAgcHJpdmF0ZSBfaGFzQmFja2Ryb3A7XHJcbiAgICBwcml2YXRlIF9sb2NrUG9zaXRpb247XHJcbiAgICBwcml2YXRlIF9ncm93QWZ0ZXJPcGVuO1xyXG4gICAgcHJpdmF0ZSBfZmxleGlibGVEaW1lbnNpb25zO1xyXG4gICAgcHJpdmF0ZSBfcHVzaDtcclxuICAgIHByaXZhdGUgX2JhY2tkcm9wU3Vic2NyaXB0aW9uO1xyXG4gICAgcHJpdmF0ZSBfb2Zmc2V0WDtcclxuICAgIHByaXZhdGUgX29mZnNldFk7XHJcbiAgICBwcml2YXRlIF9wb3NpdGlvbjtcclxuICAgIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5RmFjdG9yeTtcclxuICAgIC8qKiBPcmlnaW4gZm9yIHRoZSBjb25uZWN0ZWQgb3ZlcmxheS4gKi9cclxuICAgIG9yaWdpbjogQ2RrT3ZlcmxheU9yaWdpbjtcclxuICAgIC8qKiBSZWdpc3RlcmVkIGNvbm5lY3RlZCBwb3NpdGlvbiBwYWlycy4gKi9cclxuICAgIHBvc2l0aW9uczogQ29ubmVjdGVkUG9zaXRpb25bXTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpbnB1dCBvdmVycmlkZXMgdGhlIHBvc2l0aW9ucyBpbnB1dCBpZiBzcGVjaWZpZWQuIEl0IGxldHMgdXNlcnMgcGFzc1xyXG4gICAgICogaW4gYXJiaXRyYXJ5IHBvc2l0aW9uaW5nIHN0cmF0ZWdpZXMuXHJcbiAgICAgKi9cclxuICAgIHBvc2l0aW9uU3RyYXRlZ3k6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneTtcclxuICAgIC8qKiBUaGUgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIG92ZXJsYXkgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgeC1heGlzICovXHJcbiAgICBnZXQgb2Zmc2V0WCgpOiBudW1iZXI7XHJcbiAgICBzZXQgb2Zmc2V0WChvZmZzZXRYOiBudW1iZXIpO1xyXG4gICAgLyoqIFRoZSBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgb3ZlcmxheSBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB5LWF4aXMgKi9cclxuICAgIGdldCBvZmZzZXRZKCk6IG51bWJlcjtcclxuICAgIHNldCBvZmZzZXRZKG9mZnNldFk6IG51bWJlcik7XHJcbiAgICAvKiogVGhlIHdpZHRoIG9mIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xyXG4gICAgd2lkdGg6IG51bWJlciB8IHN0cmluZztcclxuICAgIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xyXG4gICAgaGVpZ2h0OiBudW1iZXIgfCBzdHJpbmc7XHJcbiAgICAvKiogVGhlIG1pbiB3aWR0aCBvZiB0aGUgb3ZlcmxheSBwYW5lbC4gKi9cclxuICAgIG1pbldpZHRoOiBudW1iZXIgfCBzdHJpbmc7XHJcbiAgICAvKiogVGhlIG1pbiBoZWlnaHQgb2YgdGhlIG92ZXJsYXkgcGFuZWwuICovXHJcbiAgICBtaW5IZWlnaHQ6IG51bWJlciB8IHN0cmluZztcclxuICAgIC8qKiBUaGUgY3VzdG9tIGNsYXNzIHRvIGJlIHNldCBvbiB0aGUgYmFja2Ryb3AgZWxlbWVudC4gKi9cclxuICAgIGJhY2tkcm9wQ2xhc3M6IHN0cmluZztcclxuICAgIC8qKiBUaGUgY3VzdG9tIGNsYXNzIHRvIGFkZCB0byB0aGUgb3ZlcmxheSBwYW5lIGVsZW1lbnQuICovXHJcbiAgICBwYW5lbENsYXNzOiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuICAgIC8qKiBNYXJnaW4gYmV0d2VlbiB0aGUgb3ZlcmxheSBhbmQgdGhlIHZpZXdwb3J0IGVkZ2VzLiAqL1xyXG4gICAgdmlld3BvcnRNYXJnaW46IG51bWJlcjtcclxuICAgIC8qKiBTdHJhdGVneSB0byBiZSB1c2VkIHdoZW4gaGFuZGxpbmcgc2Nyb2xsIGV2ZW50cyB3aGlsZSB0aGUgb3ZlcmxheSBpcyBvcGVuLiAqL1xyXG4gICAgc2Nyb2xsU3RyYXRlZ3k6IFNjcm9sbFN0cmF0ZWd5O1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIG92ZXJsYXkgaXMgb3Blbi4gKi9cclxuICAgIG9wZW46IGJvb2xlYW47XHJcbiAgICAvKiogQ1NTIHNlbGVjdG9yIHdoaWNoIHRvIHNldCB0aGUgdHJhbnNmb3JtIG9yaWdpbi4gKi9cclxuICAgIHRyYW5zZm9ybU9yaWdpblNlbGVjdG9yOiBzdHJpbmc7XHJcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIG92ZXJsYXkgc2hvdWxkIGF0dGFjaCBhIGJhY2tkcm9wLiAqL1xyXG4gICAgZ2V0IGhhc0JhY2tkcm9wKCk6IGFueTtcclxuICAgIHNldCBoYXNCYWNrZHJvcCh2YWx1ZTogYW55KTtcclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3ZlcmxheSBzaG91bGQgYmUgbG9ja2VkIHdoZW4gc2Nyb2xsaW5nLiAqL1xyXG4gICAgZ2V0IGxvY2tQb3NpdGlvbigpOiBhbnk7XHJcbiAgICBzZXQgbG9ja1Bvc2l0aW9uKHZhbHVlOiBhbnkpO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIG92ZXJsYXkncyB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBiZSBjb25zdHJhaW5lZCB0byBmaXQgd2l0aGluIHRoZSB2aWV3cG9ydC4gKi9cclxuICAgIGdldCBmbGV4aWJsZURpbWVuc2lvbnMoKTogYm9vbGVhbjtcclxuICAgIHNldCBmbGV4aWJsZURpbWVuc2lvbnModmFsdWU6IGJvb2xlYW4pO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIG92ZXJsYXkgY2FuIGdyb3cgYWZ0ZXIgdGhlIGluaXRpYWwgb3BlbiB3aGVuIGZsZXhpYmxlIHBvc2l0aW9uaW5nIGlzIHR1cm5lZCBvbi4gKi9cclxuICAgIGdldCBncm93QWZ0ZXJPcGVuKCk6IGJvb2xlYW47XHJcbiAgICBzZXQgZ3Jvd0FmdGVyT3Blbih2YWx1ZTogYm9vbGVhbik7XHJcbiAgICAvKiogV2hldGhlciB0aGUgb3ZlcmxheSBjYW4gYmUgcHVzaGVkIG9uLXNjcmVlbiBpZiBub25lIG9mIHRoZSBwcm92aWRlZCBwb3NpdGlvbnMgZml0LiAqL1xyXG4gICAgZ2V0IHB1c2goKTogYm9vbGVhbjtcclxuICAgIHNldCBwdXNoKHZhbHVlOiBib29sZWFuKTtcclxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGJhY2tkcm9wIGlzIGNsaWNrZWQuICovXHJcbiAgICBiYWNrZHJvcENsaWNrOiBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD47XHJcbiAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBwb3NpdGlvbiBoYXMgY2hhbmdlZC4gKi9cclxuICAgIHBvc2l0aW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Q29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlPjtcclxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIG92ZXJsYXkgaGFzIGJlZW4gYXR0YWNoZWQuICovXHJcbiAgICBhdHRhY2g6IEV2ZW50RW1pdHRlcjx2b2lkPjtcclxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIG92ZXJsYXkgaGFzIGJlZW4gZGV0YWNoZWQuICovXHJcbiAgICBkZXRhY2g6IEV2ZW50RW1pdHRlcjx2b2lkPjtcclxuICAgIC8qKiBFbWl0cyB3aGVuIHRoZXJlIGFyZSBrZXlib2FyZCBldmVudHMgdGhhdCBhcmUgdGFyZ2V0ZWQgYXQgdGhlIG92ZXJsYXkuICovXHJcbiAgICBvdmVybGF5S2V5ZG93bjogRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+O1xyXG4gICAgY29uc3RydWN0b3IoX292ZXJsYXk6IE92ZXJsYXksIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LCB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLCBzY3JvbGxTdHJhdGVneUZhY3Rvcnk6IGFueSwgX2RpcjogRGlyZWN0aW9uYWxpdHkpO1xyXG4gICAgLyoqIFRoZSBhc3NvY2lhdGVkIG92ZXJsYXkgcmVmZXJlbmNlLiAqL1xyXG4gICAgZ2V0IG92ZXJsYXlSZWYoKTogT3ZlcmxheVJlZjtcclxuICAgIC8qKiBUaGUgZWxlbWVudCdzIGxheW91dCBkaXJlY3Rpb24uICovXHJcbiAgICBnZXQgZGlyKCk6IERpcmVjdGlvbjtcclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcclxuICAgIC8qKiBDcmVhdGVzIGFuIG92ZXJsYXkgKi9cclxuICAgIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXk7XHJcbiAgICAvKiogQnVpbGRzIHRoZSBvdmVybGF5IGNvbmZpZyBiYXNlZCBvbiB0aGUgZGlyZWN0aXZlJ3MgaW5wdXRzICovXHJcbiAgICBwcml2YXRlIF9idWlsZENvbmZpZztcclxuICAgIC8qKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiBhIHBvc2l0aW9uIHN0cmF0ZWd5LCBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIHRoZSBkaXJlY3RpdmUgaW5wdXRzLiAqL1xyXG4gICAgcHJpdmF0ZSBfdXBkYXRlUG9zaXRpb25TdHJhdGVneTtcclxuICAgIC8qKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBzdHJhdGVneSBvZiB0aGUgb3ZlcmxheSB0byBiZSBzZXQgb24gdGhlIG92ZXJsYXkgY29uZmlnICovXHJcbiAgICBwcml2YXRlIF9jcmVhdGVQb3NpdGlvblN0cmF0ZWd5O1xyXG4gICAgLyoqIEF0dGFjaGVzIHRoZSBvdmVybGF5IGFuZCBzdWJzY3JpYmVzIHRvIGJhY2tkcm9wIGNsaWNrcyBpZiBiYWNrZHJvcCBleGlzdHMgKi9cclxuICAgIHByaXZhdGUgX2F0dGFjaE92ZXJsYXk7XHJcbiAgICAvKiogRGV0YWNoZXMgdGhlIG92ZXJsYXkgYW5kIHVuc3Vic2NyaWJlcyB0byBiYWNrZHJvcCBjbGlja3MgaWYgYmFja2Ryb3AgZXhpc3RzICovXHJcbiAgICBwcml2YXRlIF9kZXRhY2hPdmVybGF5O1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2hhc0JhY2tkcm9wOiBCb29sZWFuSW5wdXQ7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbG9ja1Bvc2l0aW9uOiBCb29sZWFuSW5wdXQ7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZmxleGlibGVEaW1lbnNpb25zOiBCb29sZWFuSW5wdXQ7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZ3Jvd0FmdGVyT3BlbjogQm9vbGVhbklucHV0O1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3B1c2g6IEJvb2xlYW5JbnB1dDtcclxufVxyXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBDREtfQ09OTkVDVEVEX09WRVJMQVlfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSX0ZBQ1RPUlkob3ZlcmxheTogT3ZlcmxheSk6ICgpID0+IFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneTtcclxuLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuZXhwb3J0IGRlY2xhcmUgY29uc3QgQ0RLX0NPTk5FQ1RFRF9PVkVSTEFZX1NDUk9MTF9TVFJBVEVHWV9QUk9WSURFUjoge1xyXG4gICAgcHJvdmlkZTogSW5qZWN0aW9uVG9rZW48KCkgPT4gU2Nyb2xsU3RyYXRlZ3k+O1xyXG4gICAgZGVwczogKHR5cGVvZiBPdmVybGF5KVtdO1xyXG4gICAgdXNlRmFjdG9yeTogdHlwZW9mIENES19DT05ORUNURURfT1ZFUkxBWV9TQ1JPTExfU1RSQVRFR1lfUFJPVklERVJfRkFDVE9SWTtcclxufTtcclxuIl19